From 3008c43d0dbcd690710d30f0b5318a4bbc7f1ea1 Mon Sep 17 00:00:00 2001
From: Jan Chaloupka <jchaloup@redhat.com>
Date: Thu, 8 Oct 2015 15:38:56 +0200
Subject: [PATCH] change C.int to C.blastint

---
 cgo/blas.go | 276 ++++++++++++++++++++++++++++++------------------------------
 1 file changed, 138 insertions(+), 138 deletions(-)

diff --git a/cgo/blas.go b/cgo/blas.go
index b87e2e0..8975bf1 100644
--- a/cgo/blas.go
+++ b/cgo/blas.go
@@ -88,7 +88,7 @@ func (Implementation) Srotm(n int, x []float32, incX int, y []float32, incY int,
 		flag: float32(p.Flag),
 		h:    p.H,
 	}
-	C.cblas_srotm(C.int(n), (*C.float)(&x[0]), C.int(incX), (*C.float)(&y[0]), C.int(incY), (*C.float)(unsafe.Pointer(&pi)))
+	C.cblas_srotm(C.blasint(n), (*C.float)(&x[0]), C.blasint(incX), (*C.float)(&y[0]), C.blasint(incY), (*C.float)(unsafe.Pointer(&pi)))
 }
 func (Implementation) Drotg(a float64, b float64) (c float64, s float64, r float64, z float64) {
 	C.cblas_drotg((*C.double)(&a), (*C.double)(&b), (*C.double)(&c), (*C.double)(&s))
@@ -122,7 +122,7 @@ func (Implementation) Drotm(n int, x []float64, incX int, y []float64, incY int,
 		flag: float64(p.Flag),
 		h:    p.H,
 	}
-	C.cblas_drotm(C.int(n), (*C.double)(&x[0]), C.int(incX), (*C.double)(&y[0]), C.int(incY), (*C.double)(unsafe.Pointer(&pi)))
+	C.cblas_drotm(C.blasint(n), (*C.double)(&x[0]), C.blasint(incX), (*C.double)(&y[0]), C.blasint(incY), (*C.double)(unsafe.Pointer(&pi)))
 }
 func (Implementation) Cdotu(n int, x []complex64, incX int, y []complex64, incY int) (dotu complex64) {
 	if n < 0 {
@@ -140,7 +140,7 @@ func (Implementation) Cdotu(n int, x []complex64, incX int, y []complex64, incY
 	if (incY > 0 && (n-1)*incY >= len(y)) || (incY < 0 && (1-n)*incY >= len(y)) {
 		panic("blas: y index out of range")
 	}
-	C.cblas_cdotu_sub(C.int(n), unsafe.Pointer(&x[0]), C.int(incX), unsafe.Pointer(&y[0]), C.int(incY), unsafe.Pointer(&dotu))
+	C.cblas_cdotu_sub(C.blasint(n), unsafe.Pointer(&x[0]), C.blasint(incX), unsafe.Pointer(&y[0]), C.blasint(incY), unsafe.Pointer(&dotu))
 	return dotu
 }
 func (Implementation) Cdotc(n int, x []complex64, incX int, y []complex64, incY int) (dotc complex64) {
@@ -159,7 +159,7 @@ func (Implementation) Cdotc(n int, x []complex64, incX int, y []complex64, incY
 	if (incY > 0 && (n-1)*incY >= len(y)) || (incY < 0 && (1-n)*incY >= len(y)) {
 		panic("blas: y index out of range")
 	}
-	C.cblas_cdotc_sub(C.int(n), unsafe.Pointer(&x[0]), C.int(incX), unsafe.Pointer(&y[0]), C.int(incY), unsafe.Pointer(&dotc))
+	C.cblas_cdotc_sub(C.blasint(n), unsafe.Pointer(&x[0]), C.blasint(incX), unsafe.Pointer(&y[0]), C.blasint(incY), unsafe.Pointer(&dotc))
 	return dotc
 }
 func (Implementation) Zdotu(n int, x []complex128, incX int, y []complex128, incY int) (dotu complex128) {
@@ -178,7 +178,7 @@ func (Implementation) Zdotu(n int, x []complex128, incX int, y []complex128, inc
 	if (incY > 0 && (n-1)*incY >= len(y)) || (incY < 0 && (1-n)*incY >= len(y)) {
 		panic("blas: y index out of range")
 	}
-	C.cblas_zdotu_sub(C.int(n), unsafe.Pointer(&x[0]), C.int(incX), unsafe.Pointer(&y[0]), C.int(incY), unsafe.Pointer(&dotu))
+	C.cblas_zdotu_sub(C.blasint(n), unsafe.Pointer(&x[0]), C.blasint(incX), unsafe.Pointer(&y[0]), C.blasint(incY), unsafe.Pointer(&dotu))
 	return dotu
 }
 func (Implementation) Zdotc(n int, x []complex128, incX int, y []complex128, incY int) (dotc complex128) {
@@ -197,7 +197,7 @@ func (Implementation) Zdotc(n int, x []complex128, incX int, y []complex128, inc
 	if (incY > 0 && (n-1)*incY >= len(y)) || (incY < 0 && (1-n)*incY >= len(y)) {
 		panic("blas: y index out of range")
 	}
-	C.cblas_zdotc_sub(C.int(n), unsafe.Pointer(&x[0]), C.int(incX), unsafe.Pointer(&y[0]), C.int(incY), unsafe.Pointer(&dotc))
+	C.cblas_zdotc_sub(C.blasint(n), unsafe.Pointer(&x[0]), C.blasint(incX), unsafe.Pointer(&y[0]), C.blasint(incY), unsafe.Pointer(&dotc))
 	return dotc
 }
 
@@ -217,7 +217,7 @@ func (Implementation) Sdsdot(n int, alpha float32, x []float32, incX int, y []fl
 	if (incY > 0 && (n-1)*incY >= len(y)) || (incY < 0 && (1-n)*incY >= len(y)) {
 		panic("blas: y index out of range")
 	}
-	return float32(C.cblas_sdsdot(C.int(n), C.float(alpha), (*C.float)(&x[0]), C.int(incX), (*C.float)(&y[0]), C.int(incY)))
+	return float32(C.cblas_sdsdot(C.blasint(n), C.float(alpha), (*C.float)(&x[0]), C.blasint(incX), (*C.float)(&y[0]), C.blasint(incY)))
 }
 func (Implementation) Dsdot(n int, x []float32, incX int, y []float32, incY int) float64 {
 	if n < 0 {
@@ -235,7 +235,7 @@ func (Implementation) Dsdot(n int, x []float32, incX int, y []float32, incY int)
 	if (incY > 0 && (n-1)*incY >= len(y)) || (incY < 0 && (1-n)*incY >= len(y)) {
 		panic("blas: y index out of range")
 	}
-	return float64(C.cblas_dsdot(C.int(n), (*C.float)(&x[0]), C.int(incX), (*C.float)(&y[0]), C.int(incY)))
+	return float64(C.cblas_dsdot(C.blasint(n), (*C.float)(&x[0]), C.blasint(incX), (*C.float)(&y[0]), C.blasint(incY)))
 }
 func (Implementation) Sdot(n int, x []float32, incX int, y []float32, incY int) float32 {
 	if n < 0 {
@@ -253,7 +253,7 @@ func (Implementation) Sdot(n int, x []float32, incX int, y []float32, incY int)
 	if (incY > 0 && (n-1)*incY >= len(y)) || (incY < 0 && (1-n)*incY >= len(y)) {
 		panic("blas: y index out of range")
 	}
-	return float32(C.cblas_sdot(C.int(n), (*C.float)(&x[0]), C.int(incX), (*C.float)(&y[0]), C.int(incY)))
+	return float32(C.cblas_sdot(C.blasint(n), (*C.float)(&x[0]), C.blasint(incX), (*C.float)(&y[0]), C.blasint(incY)))
 }
 func (Implementation) Ddot(n int, x []float64, incX int, y []float64, incY int) float64 {
 	if n < 0 {
@@ -271,7 +271,7 @@ func (Implementation) Ddot(n int, x []float64, incX int, y []float64, incY int)
 	if (incY > 0 && (n-1)*incY >= len(y)) || (incY < 0 && (1-n)*incY >= len(y)) {
 		panic("blas: y index out of range")
 	}
-	return float64(C.cblas_ddot(C.int(n), (*C.double)(&x[0]), C.int(incX), (*C.double)(&y[0]), C.int(incY)))
+	return float64(C.cblas_ddot(C.blasint(n), (*C.double)(&x[0]), C.blasint(incX), (*C.double)(&y[0]), C.blasint(incY)))
 }
 func (Implementation) Snrm2(n int, x []float32, incX int) float32 {
 	if n < 0 {
@@ -286,7 +286,7 @@ func (Implementation) Snrm2(n int, x []float32, incX int) float32 {
 	if incX > 0 && (n-1)*incX >= len(x) {
 		panic("blas: x index out of range")
 	}
-	return float32(C.cblas_snrm2(C.int(n), (*C.float)(&x[0]), C.int(incX)))
+	return float32(C.cblas_snrm2(C.blasint(n), (*C.float)(&x[0]), C.blasint(incX)))
 }
 func (Implementation) Sasum(n int, x []float32, incX int) float32 {
 	if n < 0 {
@@ -301,7 +301,7 @@ func (Implementation) Sasum(n int, x []float32, incX int) float32 {
 	if incX > 0 && (n-1)*incX >= len(x) {
 		panic("blas: x index out of range")
 	}
-	return float32(C.cblas_sasum(C.int(n), (*C.float)(&x[0]), C.int(incX)))
+	return float32(C.cblas_sasum(C.blasint(n), (*C.float)(&x[0]), C.blasint(incX)))
 }
 func (Implementation) Dnrm2(n int, x []float64, incX int) float64 {
 	if n < 0 {
@@ -316,7 +316,7 @@ func (Implementation) Dnrm2(n int, x []float64, incX int) float64 {
 	if incX > 0 && (n-1)*incX >= len(x) {
 		panic("blas: x index out of range")
 	}
-	return float64(C.cblas_dnrm2(C.int(n), (*C.double)(&x[0]), C.int(incX)))
+	return float64(C.cblas_dnrm2(C.blasint(n), (*C.double)(&x[0]), C.blasint(incX)))
 }
 func (Implementation) Dasum(n int, x []float64, incX int) float64 {
 	if n < 0 {
@@ -331,7 +331,7 @@ func (Implementation) Dasum(n int, x []float64, incX int) float64 {
 	if incX > 0 && (n-1)*incX >= len(x) {
 		panic("blas: x index out of range")
 	}
-	return float64(C.cblas_dasum(C.int(n), (*C.double)(&x[0]), C.int(incX)))
+	return float64(C.cblas_dasum(C.blasint(n), (*C.double)(&x[0]), C.blasint(incX)))
 }
 func (Implementation) Scnrm2(n int, x []complex64, incX int) float32 {
 	if n < 0 {
@@ -346,7 +346,7 @@ func (Implementation) Scnrm2(n int, x []complex64, incX int) float32 {
 	if incX > 0 && (n-1)*incX >= len(x) {
 		panic("blas: x index out of range")
 	}
-	return float32(C.cblas_scnrm2(C.int(n), unsafe.Pointer(&x[0]), C.int(incX)))
+	return float32(C.cblas_scnrm2(C.blasint(n), unsafe.Pointer(&x[0]), C.blasint(incX)))
 }
 func (Implementation) Scasum(n int, x []complex64, incX int) float32 {
 	if n < 0 {
@@ -361,7 +361,7 @@ func (Implementation) Scasum(n int, x []complex64, incX int) float32 {
 	if incX > 0 && (n-1)*incX >= len(x) {
 		panic("blas: x index out of range")
 	}
-	return float32(C.cblas_scasum(C.int(n), unsafe.Pointer(&x[0]), C.int(incX)))
+	return float32(C.cblas_scasum(C.blasint(n), unsafe.Pointer(&x[0]), C.blasint(incX)))
 }
 func (Implementation) Dznrm2(n int, x []complex128, incX int) float64 {
 	if n < 0 {
@@ -376,7 +376,7 @@ func (Implementation) Dznrm2(n int, x []complex128, incX int) float64 {
 	if incX > 0 && (n-1)*incX >= len(x) {
 		panic("blas: x index out of range")
 	}
-	return float64(C.cblas_dznrm2(C.int(n), unsafe.Pointer(&x[0]), C.int(incX)))
+	return float64(C.cblas_dznrm2(C.blasint(n), unsafe.Pointer(&x[0]), C.blasint(incX)))
 }
 func (Implementation) Dzasum(n int, x []complex128, incX int) float64 {
 	if n < 0 {
@@ -391,7 +391,7 @@ func (Implementation) Dzasum(n int, x []complex128, incX int) float64 {
 	if incX > 0 && (n-1)*incX >= len(x) {
 		panic("blas: x index out of range")
 	}
-	return float64(C.cblas_dzasum(C.int(n), unsafe.Pointer(&x[0]), C.int(incX)))
+	return float64(C.cblas_dzasum(C.blasint(n), unsafe.Pointer(&x[0]), C.blasint(incX)))
 }
 func (Implementation) Isamax(n int, x []float32, incX int) int {
 	if n < 0 {
@@ -406,7 +406,7 @@ func (Implementation) Isamax(n int, x []float32, incX int) int {
 	if incX > 0 && (n-1)*incX >= len(x) {
 		panic("blas: x index out of range")
 	}
-	return int(C.cblas_isamax(C.int(n), (*C.float)(&x[0]), C.int(incX)))
+	return int(C.cblas_isamax(C.blasint(n), (*C.float)(&x[0]), C.blasint(incX)))
 }
 func (Implementation) Idamax(n int, x []float64, incX int) int {
 	if n < 0 {
@@ -421,7 +421,7 @@ func (Implementation) Idamax(n int, x []float64, incX int) int {
 	if incX > 0 && (n-1)*incX >= len(x) {
 		panic("blas: x index out of range")
 	}
-	return int(C.cblas_idamax(C.int(n), (*C.double)(&x[0]), C.int(incX)))
+	return int(C.cblas_idamax(C.blasint(n), (*C.double)(&x[0]), C.blasint(incX)))
 }
 func (Implementation) Icamax(n int, x []complex64, incX int) int {
 	if n < 0 {
@@ -436,7 +436,7 @@ func (Implementation) Icamax(n int, x []complex64, incX int) int {
 	if incX > 0 && (n-1)*incX >= len(x) {
 		panic("blas: x index out of range")
 	}
-	return int(C.cblas_icamax(C.int(n), unsafe.Pointer(&x[0]), C.int(incX)))
+	return int(C.cblas_icamax(C.blasint(n), unsafe.Pointer(&x[0]), C.blasint(incX)))
 }
 func (Implementation) Izamax(n int, x []complex128, incX int) int {
 	if n < 0 {
@@ -451,7 +451,7 @@ func (Implementation) Izamax(n int, x []complex128, incX int) int {
 	if incX > 0 && (n-1)*incX >= len(x) {
 		panic("blas: x index out of range")
 	}
-	return int(C.cblas_izamax(C.int(n), unsafe.Pointer(&x[0]), C.int(incX)))
+	return int(C.cblas_izamax(C.blasint(n), unsafe.Pointer(&x[0]), C.blasint(incX)))
 }
 func (Implementation) Sswap(n int, x []float32, incX int, y []float32, incY int) {
 	if n < 0 {
@@ -469,7 +469,7 @@ func (Implementation) Sswap(n int, x []float32, incX int, y []float32, incY int)
 	if (incY > 0 && (n-1)*incY >= len(y)) || (incY < 0 && (1-n)*incY >= len(y)) {
 		panic("blas: y index out of range")
 	}
-	C.cblas_sswap(C.int(n), (*C.float)(&x[0]), C.int(incX), (*C.float)(&y[0]), C.int(incY))
+	C.cblas_sswap(C.blasint(n), (*C.float)(&x[0]), C.blasint(incX), (*C.float)(&y[0]), C.blasint(incY))
 }
 func (Implementation) Scopy(n int, x []float32, incX int, y []float32, incY int) {
 	if n < 0 {
@@ -487,7 +487,7 @@ func (Implementation) Scopy(n int, x []float32, incX int, y []float32, incY int)
 	if (incY > 0 && (n-1)*incY >= len(y)) || (incY < 0 && (1-n)*incY >= len(y)) {
 		panic("blas: y index out of range")
 	}
-	C.cblas_scopy(C.int(n), (*C.float)(&x[0]), C.int(incX), (*C.float)(&y[0]), C.int(incY))
+	C.cblas_scopy(C.blasint(n), (*C.float)(&x[0]), C.blasint(incX), (*C.float)(&y[0]), C.blasint(incY))
 }
 func (Implementation) Saxpy(n int, alpha float32, x []float32, incX int, y []float32, incY int) {
 	if n < 0 {
@@ -505,7 +505,7 @@ func (Implementation) Saxpy(n int, alpha float32, x []float32, incX int, y []flo
 	if (incY > 0 && (n-1)*incY >= len(y)) || (incY < 0 && (1-n)*incY >= len(y)) {
 		panic("blas: y index out of range")
 	}
-	C.cblas_saxpy(C.int(n), C.float(alpha), (*C.float)(&x[0]), C.int(incX), (*C.float)(&y[0]), C.int(incY))
+	C.cblas_saxpy(C.blasint(n), C.float(alpha), (*C.float)(&x[0]), C.blasint(incX), (*C.float)(&y[0]), C.blasint(incY))
 }
 func (Implementation) Dswap(n int, x []float64, incX int, y []float64, incY int) {
 	if n < 0 {
@@ -523,7 +523,7 @@ func (Implementation) Dswap(n int, x []float64, incX int, y []float64, incY int)
 	if (incY > 0 && (n-1)*incY >= len(y)) || (incY < 0 && (1-n)*incY >= len(y)) {
 		panic("blas: y index out of range")
 	}
-	C.cblas_dswap(C.int(n), (*C.double)(&x[0]), C.int(incX), (*C.double)(&y[0]), C.int(incY))
+	C.cblas_dswap(C.blasint(n), (*C.double)(&x[0]), C.blasint(incX), (*C.double)(&y[0]), C.blasint(incY))
 }
 func (Implementation) Dcopy(n int, x []float64, incX int, y []float64, incY int) {
 	if n < 0 {
@@ -541,7 +541,7 @@ func (Implementation) Dcopy(n int, x []float64, incX int, y []float64, incY int)
 	if (incY > 0 && (n-1)*incY >= len(y)) || (incY < 0 && (1-n)*incY >= len(y)) {
 		panic("blas: y index out of range")
 	}
-	C.cblas_dcopy(C.int(n), (*C.double)(&x[0]), C.int(incX), (*C.double)(&y[0]), C.int(incY))
+	C.cblas_dcopy(C.blasint(n), (*C.double)(&x[0]), C.blasint(incX), (*C.double)(&y[0]), C.blasint(incY))
 }
 func (Implementation) Daxpy(n int, alpha float64, x []float64, incX int, y []float64, incY int) {
 	if n < 0 {
@@ -559,7 +559,7 @@ func (Implementation) Daxpy(n int, alpha float64, x []float64, incX int, y []flo
 	if (incY > 0 && (n-1)*incY >= len(y)) || (incY < 0 && (1-n)*incY >= len(y)) {
 		panic("blas: y index out of range")
 	}
-	C.cblas_daxpy(C.int(n), C.double(alpha), (*C.double)(&x[0]), C.int(incX), (*C.double)(&y[0]), C.int(incY))
+	C.cblas_daxpy(C.blasint(n), C.double(alpha), (*C.double)(&x[0]), C.blasint(incX), (*C.double)(&y[0]), C.blasint(incY))
 }
 func (Implementation) Cswap(n int, x []complex64, incX int, y []complex64, incY int) {
 	if n < 0 {
@@ -577,7 +577,7 @@ func (Implementation) Cswap(n int, x []complex64, incX int, y []complex64, incY
 	if (incY > 0 && (n-1)*incY >= len(y)) || (incY < 0 && (1-n)*incY >= len(y)) {
 		panic("blas: y index out of range")
 	}
-	C.cblas_cswap(C.int(n), unsafe.Pointer(&x[0]), C.int(incX), unsafe.Pointer(&y[0]), C.int(incY))
+	C.cblas_cswap(C.blasint(n), unsafe.Pointer(&x[0]), C.blasint(incX), unsafe.Pointer(&y[0]), C.blasint(incY))
 }
 func (Implementation) Ccopy(n int, x []complex64, incX int, y []complex64, incY int) {
 	if n < 0 {
@@ -595,7 +595,7 @@ func (Implementation) Ccopy(n int, x []complex64, incX int, y []complex64, incY
 	if (incY > 0 && (n-1)*incY >= len(y)) || (incY < 0 && (1-n)*incY >= len(y)) {
 		panic("blas: y index out of range")
 	}
-	C.cblas_ccopy(C.int(n), unsafe.Pointer(&x[0]), C.int(incX), unsafe.Pointer(&y[0]), C.int(incY))
+	C.cblas_ccopy(C.blasint(n), unsafe.Pointer(&x[0]), C.blasint(incX), unsafe.Pointer(&y[0]), C.blasint(incY))
 }
 func (Implementation) Caxpy(n int, alpha complex64, x []complex64, incX int, y []complex64, incY int) {
 	if n < 0 {
@@ -613,7 +613,7 @@ func (Implementation) Caxpy(n int, alpha complex64, x []complex64, incX int, y [
 	if (incY > 0 && (n-1)*incY >= len(y)) || (incY < 0 && (1-n)*incY >= len(y)) {
 		panic("blas: y index out of range")
 	}
-	C.cblas_caxpy(C.int(n), unsafe.Pointer(&alpha), unsafe.Pointer(&x[0]), C.int(incX), unsafe.Pointer(&y[0]), C.int(incY))
+	C.cblas_caxpy(C.blasint(n), unsafe.Pointer(&alpha), unsafe.Pointer(&x[0]), C.blasint(incX), unsafe.Pointer(&y[0]), C.blasint(incY))
 }
 func (Implementation) Zswap(n int, x []complex128, incX int, y []complex128, incY int) {
 	if n < 0 {
@@ -631,7 +631,7 @@ func (Implementation) Zswap(n int, x []complex128, incX int, y []complex128, inc
 	if (incY > 0 && (n-1)*incY >= len(y)) || (incY < 0 && (1-n)*incY >= len(y)) {
 		panic("blas: y index out of range")
 	}
-	C.cblas_zswap(C.int(n), unsafe.Pointer(&x[0]), C.int(incX), unsafe.Pointer(&y[0]), C.int(incY))
+	C.cblas_zswap(C.blasint(n), unsafe.Pointer(&x[0]), C.blasint(incX), unsafe.Pointer(&y[0]), C.blasint(incY))
 }
 func (Implementation) Zcopy(n int, x []complex128, incX int, y []complex128, incY int) {
 	if n < 0 {
@@ -649,7 +649,7 @@ func (Implementation) Zcopy(n int, x []complex128, incX int, y []complex128, inc
 	if (incY > 0 && (n-1)*incY >= len(y)) || (incY < 0 && (1-n)*incY >= len(y)) {
 		panic("blas: y index out of range")
 	}
-	C.cblas_zcopy(C.int(n), unsafe.Pointer(&x[0]), C.int(incX), unsafe.Pointer(&y[0]), C.int(incY))
+	C.cblas_zcopy(C.blasint(n), unsafe.Pointer(&x[0]), C.blasint(incX), unsafe.Pointer(&y[0]), C.blasint(incY))
 }
 func (Implementation) Zaxpy(n int, alpha complex128, x []complex128, incX int, y []complex128, incY int) {
 	if n < 0 {
@@ -667,7 +667,7 @@ func (Implementation) Zaxpy(n int, alpha complex128, x []complex128, incX int, y
 	if (incY > 0 && (n-1)*incY >= len(y)) || (incY < 0 && (1-n)*incY >= len(y)) {
 		panic("blas: y index out of range")
 	}
-	C.cblas_zaxpy(C.int(n), unsafe.Pointer(&alpha), unsafe.Pointer(&x[0]), C.int(incX), unsafe.Pointer(&y[0]), C.int(incY))
+	C.cblas_zaxpy(C.blasint(n), unsafe.Pointer(&alpha), unsafe.Pointer(&x[0]), C.blasint(incX), unsafe.Pointer(&y[0]), C.blasint(incY))
 }
 func (Implementation) Srot(n int, x []float32, incX int, y []float32, incY int, c float32, s float32) {
 	if n < 0 {
@@ -685,7 +685,7 @@ func (Implementation) Srot(n int, x []float32, incX int, y []float32, incY int,
 	if (incY > 0 && (n-1)*incY >= len(y)) || (incY < 0 && (1-n)*incY >= len(y)) {
 		panic("blas: y index out of range")
 	}
-	C.cblas_srot(C.int(n), (*C.float)(&x[0]), C.int(incX), (*C.float)(&y[0]), C.int(incY), C.float(c), C.float(s))
+	C.cblas_srot(C.blasint(n), (*C.float)(&x[0]), C.blasint(incX), (*C.float)(&y[0]), C.blasint(incY), C.float(c), C.float(s))
 }
 func (Implementation) Drot(n int, x []float64, incX int, y []float64, incY int, c float64, s float64) {
 	if n < 0 {
@@ -703,7 +703,7 @@ func (Implementation) Drot(n int, x []float64, incX int, y []float64, incY int,
 	if (incY > 0 && (n-1)*incY >= len(y)) || (incY < 0 && (1-n)*incY >= len(y)) {
 		panic("blas: y index out of range")
 	}
-	C.cblas_drot(C.int(n), (*C.double)(&x[0]), C.int(incX), (*C.double)(&y[0]), C.int(incY), C.double(c), C.double(s))
+	C.cblas_drot(C.blasint(n), (*C.double)(&x[0]), C.blasint(incX), (*C.double)(&y[0]), C.blasint(incY), C.double(c), C.double(s))
 }
 func (Implementation) Sscal(n int, alpha float32, x []float32, incX int) {
 	if n < 0 {
@@ -718,7 +718,7 @@ func (Implementation) Sscal(n int, alpha float32, x []float32, incX int) {
 	if incX > 0 && (n-1)*incX >= len(x) {
 		panic("blas: x index out of range")
 	}
-	C.cblas_sscal(C.int(n), C.float(alpha), (*C.float)(&x[0]), C.int(incX))
+	C.cblas_sscal(C.blasint(n), C.float(alpha), (*C.float)(&x[0]), C.blasint(incX))
 }
 func (Implementation) Dscal(n int, alpha float64, x []float64, incX int) {
 	if n < 0 {
@@ -733,7 +733,7 @@ func (Implementation) Dscal(n int, alpha float64, x []float64, incX int) {
 	if incX > 0 && (n-1)*incX >= len(x) {
 		panic("blas: x index out of range")
 	}
-	C.cblas_dscal(C.int(n), C.double(alpha), (*C.double)(&x[0]), C.int(incX))
+	C.cblas_dscal(C.blasint(n), C.double(alpha), (*C.double)(&x[0]), C.blasint(incX))
 }
 func (Implementation) Cscal(n int, alpha complex64, x []complex64, incX int) {
 	if n < 0 {
@@ -748,7 +748,7 @@ func (Implementation) Cscal(n int, alpha complex64, x []complex64, incX int) {
 	if incX > 0 && (n-1)*incX >= len(x) {
 		panic("blas: x index out of range")
 	}
-	C.cblas_cscal(C.int(n), unsafe.Pointer(&alpha), unsafe.Pointer(&x[0]), C.int(incX))
+	C.cblas_cscal(C.blasint(n), unsafe.Pointer(&alpha), unsafe.Pointer(&x[0]), C.blasint(incX))
 }
 func (Implementation) Zscal(n int, alpha complex128, x []complex128, incX int) {
 	if n < 0 {
@@ -763,7 +763,7 @@ func (Implementation) Zscal(n int, alpha complex128, x []complex128, incX int) {
 	if incX > 0 && (n-1)*incX >= len(x) {
 		panic("blas: x index out of range")
 	}
-	C.cblas_zscal(C.int(n), unsafe.Pointer(&alpha), unsafe.Pointer(&x[0]), C.int(incX))
+	C.cblas_zscal(C.blasint(n), unsafe.Pointer(&alpha), unsafe.Pointer(&x[0]), C.blasint(incX))
 }
 func (Implementation) Csscal(n int, alpha float32, x []complex64, incX int) {
 	if n < 0 {
@@ -778,7 +778,7 @@ func (Implementation) Csscal(n int, alpha float32, x []complex64, incX int) {
 	if incX > 0 && (n-1)*incX >= len(x) {
 		panic("blas: x index out of range")
 	}
-	C.cblas_csscal(C.int(n), C.float(alpha), unsafe.Pointer(&x[0]), C.int(incX))
+	C.cblas_csscal(C.blasint(n), C.float(alpha), unsafe.Pointer(&x[0]), C.blasint(incX))
 }
 func (Implementation) Zdscal(n int, alpha float64, x []complex128, incX int) {
 	if n < 0 {
@@ -790,7 +790,7 @@ func (Implementation) Zdscal(n int, alpha float64, x []complex128, incX int) {
 	if (incX > 0 && (n-1)*incX >= len(x)) || (incX < 0 && (1-n)*incX >= len(x)) {
 		panic("blas: x index out of range")
 	}
-	C.cblas_zdscal(C.int(n), C.double(alpha), unsafe.Pointer(&x[0]), C.int(incX))
+	C.cblas_zdscal(C.blasint(n), C.double(alpha), unsafe.Pointer(&x[0]), C.blasint(incX))
 }
 func (Implementation) Sgemv(tA blas.Transpose, m int, n int, alpha float32, a []float32, lda int, x []float32, incX int, beta float32, y []float32, incY int) {
 	if tA != blas.NoTrans && tA != blas.Trans && tA != blas.ConjTrans {
@@ -823,7 +823,7 @@ func (Implementation) Sgemv(tA blas.Transpose, m int, n int, alpha float32, a []
 	if lda*(m-1)+n > len(a) || lda < max(1, n) {
 		panic("blas: index of a out of range")
 	}
-	C.cblas_sgemv(C.enum_CBLAS_ORDER(rowMajor), C.enum_CBLAS_TRANSPOSE(tA), C.int(m), C.int(n), C.float(alpha), (*C.float)(&a[0]), C.int(lda), (*C.float)(&x[0]), C.int(incX), C.float(beta), (*C.float)(&y[0]), C.int(incY))
+	C.cblas_sgemv(C.enum_CBLAS_ORDER(rowMajor), C.enum_CBLAS_TRANSPOSE(tA), C.blasint(m), C.blasint(n), C.float(alpha), (*C.float)(&a[0]), C.blasint(lda), (*C.float)(&x[0]), C.blasint(incX), C.float(beta), (*C.float)(&y[0]), C.blasint(incY))
 }
 func (Implementation) Sgbmv(tA blas.Transpose, m int, n int, kL int, kU int, alpha float32, a []float32, lda int, x []float32, incX int, beta float32, y []float32, incY int) {
 	if tA != blas.NoTrans && tA != blas.Trans && tA != blas.ConjTrans {
@@ -862,7 +862,7 @@ func (Implementation) Sgbmv(tA blas.Transpose, m int, n int, kL int, kU int, alp
 	if lda*(m-1)+kL+kU+1 > len(a) || lda < kL+kU+1 {
 		panic("blas: index of a out of range")
 	}
-	C.cblas_sgbmv(C.enum_CBLAS_ORDER(rowMajor), C.enum_CBLAS_TRANSPOSE(tA), C.int(m), C.int(n), C.int(kL), C.int(kU), C.float(alpha), (*C.float)(&a[0]), C.int(lda), (*C.float)(&x[0]), C.int(incX), C.float(beta), (*C.float)(&y[0]), C.int(incY))
+	C.cblas_sgbmv(C.enum_CBLAS_ORDER(rowMajor), C.enum_CBLAS_TRANSPOSE(tA), C.blasint(m), C.blasint(n), C.blasint(kL), C.blasint(kU), C.float(alpha), (*C.float)(&a[0]), C.blasint(lda), (*C.float)(&x[0]), C.blasint(incX), C.float(beta), (*C.float)(&y[0]), C.blasint(incY))
 }
 func (Implementation) Strmv(ul blas.Uplo, tA blas.Transpose, d blas.Diag, n int, a []float32, lda int, x []float32, incX int) {
 	if ul != blas.Upper && ul != blas.Lower {
@@ -886,7 +886,7 @@ func (Implementation) Strmv(ul blas.Uplo, tA blas.Transpose, d blas.Diag, n int,
 	if lda*(n-1)+n > len(a) || lda < max(1, n) {
 		panic("blas: index of a out of range")
 	}
-	C.cblas_strmv(C.enum_CBLAS_ORDER(rowMajor), C.enum_CBLAS_UPLO(ul), C.enum_CBLAS_TRANSPOSE(tA), C.enum_CBLAS_DIAG(d), C.int(n), (*C.float)(&a[0]), C.int(lda), (*C.float)(&x[0]), C.int(incX))
+	C.cblas_strmv(C.enum_CBLAS_ORDER(rowMajor), C.enum_CBLAS_UPLO(ul), C.enum_CBLAS_TRANSPOSE(tA), C.enum_CBLAS_DIAG(d), C.blasint(n), (*C.float)(&a[0]), C.blasint(lda), (*C.float)(&x[0]), C.blasint(incX))
 }
 func (Implementation) Stbmv(ul blas.Uplo, tA blas.Transpose, d blas.Diag, n int, k int, a []float32, lda int, x []float32, incX int) {
 	if ul != blas.Upper && ul != blas.Lower {
@@ -913,7 +913,7 @@ func (Implementation) Stbmv(ul blas.Uplo, tA blas.Transpose, d blas.Diag, n int,
 	if lda*(n-1)+k+1 > len(a) || lda < k+1 {
 		panic("blas: index of a out of range")
 	}
-	C.cblas_stbmv(C.enum_CBLAS_ORDER(rowMajor), C.enum_CBLAS_UPLO(ul), C.enum_CBLAS_TRANSPOSE(tA), C.enum_CBLAS_DIAG(d), C.int(n), C.int(k), (*C.float)(&a[0]), C.int(lda), (*C.float)(&x[0]), C.int(incX))
+	C.cblas_stbmv(C.enum_CBLAS_ORDER(rowMajor), C.enum_CBLAS_UPLO(ul), C.enum_CBLAS_TRANSPOSE(tA), C.enum_CBLAS_DIAG(d), C.blasint(n), C.blasint(k), (*C.float)(&a[0]), C.blasint(lda), (*C.float)(&x[0]), C.blasint(incX))
 }
 func (Implementation) Stpmv(ul blas.Uplo, tA blas.Transpose, d blas.Diag, n int, ap []float32, x []float32, incX int) {
 	if ul != blas.Upper && ul != blas.Lower {
@@ -937,7 +937,7 @@ func (Implementation) Stpmv(ul blas.Uplo, tA blas.Transpose, d blas.Diag, n int,
 	if (incX > 0 && (n-1)*incX >= len(x)) || (incX < 0 && (1-n)*incX >= len(x)) {
 		panic("blas: x index out of range")
 	}
-	C.cblas_stpmv(C.enum_CBLAS_ORDER(rowMajor), C.enum_CBLAS_UPLO(ul), C.enum_CBLAS_TRANSPOSE(tA), C.enum_CBLAS_DIAG(d), C.int(n), (*C.float)(&ap[0]), (*C.float)(&x[0]), C.int(incX))
+	C.cblas_stpmv(C.enum_CBLAS_ORDER(rowMajor), C.enum_CBLAS_UPLO(ul), C.enum_CBLAS_TRANSPOSE(tA), C.enum_CBLAS_DIAG(d), C.blasint(n), (*C.float)(&ap[0]), (*C.float)(&x[0]), C.blasint(incX))
 }
 func (Implementation) Strsv(ul blas.Uplo, tA blas.Transpose, d blas.Diag, n int, a []float32, lda int, x []float32, incX int) {
 	if ul != blas.Upper && ul != blas.Lower {
@@ -961,7 +961,7 @@ func (Implementation) Strsv(ul blas.Uplo, tA blas.Transpose, d blas.Diag, n int,
 	if lda*(n-1)+n > len(a) || lda < max(1, n) {
 		panic("blas: index of a out of range")
 	}
-	C.cblas_strsv(C.enum_CBLAS_ORDER(rowMajor), C.enum_CBLAS_UPLO(ul), C.enum_CBLAS_TRANSPOSE(tA), C.enum_CBLAS_DIAG(d), C.int(n), (*C.float)(&a[0]), C.int(lda), (*C.float)(&x[0]), C.int(incX))
+	C.cblas_strsv(C.enum_CBLAS_ORDER(rowMajor), C.enum_CBLAS_UPLO(ul), C.enum_CBLAS_TRANSPOSE(tA), C.enum_CBLAS_DIAG(d), C.blasint(n), (*C.float)(&a[0]), C.blasint(lda), (*C.float)(&x[0]), C.blasint(incX))
 }
 func (Implementation) Stbsv(ul blas.Uplo, tA blas.Transpose, d blas.Diag, n int, k int, a []float32, lda int, x []float32, incX int) {
 	if ul != blas.Upper && ul != blas.Lower {
@@ -988,7 +988,7 @@ func (Implementation) Stbsv(ul blas.Uplo, tA blas.Transpose, d blas.Diag, n int,
 	if lda*(n-1)+k+1 > len(a) || lda < k+1 {
 		panic("blas: index of a out of range")
 	}
-	C.cblas_stbsv(C.enum_CBLAS_ORDER(rowMajor), C.enum_CBLAS_UPLO(ul), C.enum_CBLAS_TRANSPOSE(tA), C.enum_CBLAS_DIAG(d), C.int(n), C.int(k), (*C.float)(&a[0]), C.int(lda), (*C.float)(&x[0]), C.int(incX))
+	C.cblas_stbsv(C.enum_CBLAS_ORDER(rowMajor), C.enum_CBLAS_UPLO(ul), C.enum_CBLAS_TRANSPOSE(tA), C.enum_CBLAS_DIAG(d), C.blasint(n), C.blasint(k), (*C.float)(&a[0]), C.blasint(lda), (*C.float)(&x[0]), C.blasint(incX))
 }
 func (Implementation) Stpsv(ul blas.Uplo, tA blas.Transpose, d blas.Diag, n int, ap []float32, x []float32, incX int) {
 	if ul != blas.Upper && ul != blas.Lower {
@@ -1012,7 +1012,7 @@ func (Implementation) Stpsv(ul blas.Uplo, tA blas.Transpose, d blas.Diag, n int,
 	if (incX > 0 && (n-1)*incX >= len(x)) || (incX < 0 && (1-n)*incX >= len(x)) {
 		panic("blas: x index out of range")
 	}
-	C.cblas_stpsv(C.enum_CBLAS_ORDER(rowMajor), C.enum_CBLAS_UPLO(ul), C.enum_CBLAS_TRANSPOSE(tA), C.enum_CBLAS_DIAG(d), C.int(n), (*C.float)(&ap[0]), (*C.float)(&x[0]), C.int(incX))
+	C.cblas_stpsv(C.enum_CBLAS_ORDER(rowMajor), C.enum_CBLAS_UPLO(ul), C.enum_CBLAS_TRANSPOSE(tA), C.enum_CBLAS_DIAG(d), C.blasint(n), (*C.float)(&ap[0]), (*C.float)(&x[0]), C.blasint(incX))
 }
 func (Implementation) Dgemv(tA blas.Transpose, m int, n int, alpha float64, a []float64, lda int, x []float64, incX int, beta float64, y []float64, incY int) {
 	if tA != blas.NoTrans && tA != blas.Trans && tA != blas.ConjTrans {
@@ -1045,7 +1045,7 @@ func (Implementation) Dgemv(tA blas.Transpose, m int, n int, alpha float64, a []
 	if lda*(m-1)+n > len(a) || lda < max(1, n) {
 		panic("blas: index of a out of range")
 	}
-	C.cblas_dgemv(C.enum_CBLAS_ORDER(rowMajor), C.enum_CBLAS_TRANSPOSE(tA), C.int(m), C.int(n), C.double(alpha), (*C.double)(&a[0]), C.int(lda), (*C.double)(&x[0]), C.int(incX), C.double(beta), (*C.double)(&y[0]), C.int(incY))
+	C.cblas_dgemv(C.enum_CBLAS_ORDER(rowMajor), C.enum_CBLAS_TRANSPOSE(tA), C.blasint(m), C.blasint(n), C.double(alpha), (*C.double)(&a[0]), C.blasint(lda), (*C.double)(&x[0]), C.blasint(incX), C.double(beta), (*C.double)(&y[0]), C.blasint(incY))
 }
 func (Implementation) Dgbmv(tA blas.Transpose, m int, n int, kL int, kU int, alpha float64, a []float64, lda int, x []float64, incX int, beta float64, y []float64, incY int) {
 	if tA != blas.NoTrans && tA != blas.Trans && tA != blas.ConjTrans {
@@ -1084,7 +1084,7 @@ func (Implementation) Dgbmv(tA blas.Transpose, m int, n int, kL int, kU int, alp
 	if lda*(m-1)+kL+kU+1 > len(a) || lda < kL+kU+1 {
 		panic("blas: index of a out of range")
 	}
-	C.cblas_dgbmv(C.enum_CBLAS_ORDER(rowMajor), C.enum_CBLAS_TRANSPOSE(tA), C.int(m), C.int(n), C.int(kL), C.int(kU), C.double(alpha), (*C.double)(&a[0]), C.int(lda), (*C.double)(&x[0]), C.int(incX), C.double(beta), (*C.double)(&y[0]), C.int(incY))
+	C.cblas_dgbmv(C.enum_CBLAS_ORDER(rowMajor), C.enum_CBLAS_TRANSPOSE(tA), C.blasint(m), C.blasint(n), C.blasint(kL), C.blasint(kU), C.double(alpha), (*C.double)(&a[0]), C.blasint(lda), (*C.double)(&x[0]), C.blasint(incX), C.double(beta), (*C.double)(&y[0]), C.blasint(incY))
 }
 func (Implementation) Dtrmv(ul blas.Uplo, tA blas.Transpose, d blas.Diag, n int, a []float64, lda int, x []float64, incX int) {
 	if ul != blas.Upper && ul != blas.Lower {
@@ -1108,7 +1108,7 @@ func (Implementation) Dtrmv(ul blas.Uplo, tA blas.Transpose, d blas.Diag, n int,
 	if lda*(n-1)+n > len(a) || lda < max(1, n) {
 		panic("blas: index of a out of range")
 	}
-	C.cblas_dtrmv(C.enum_CBLAS_ORDER(rowMajor), C.enum_CBLAS_UPLO(ul), C.enum_CBLAS_TRANSPOSE(tA), C.enum_CBLAS_DIAG(d), C.int(n), (*C.double)(&a[0]), C.int(lda), (*C.double)(&x[0]), C.int(incX))
+	C.cblas_dtrmv(C.enum_CBLAS_ORDER(rowMajor), C.enum_CBLAS_UPLO(ul), C.enum_CBLAS_TRANSPOSE(tA), C.enum_CBLAS_DIAG(d), C.blasint(n), (*C.double)(&a[0]), C.blasint(lda), (*C.double)(&x[0]), C.blasint(incX))
 }
 func (Implementation) Dtbmv(ul blas.Uplo, tA blas.Transpose, d blas.Diag, n int, k int, a []float64, lda int, x []float64, incX int) {
 	if ul != blas.Upper && ul != blas.Lower {
@@ -1135,7 +1135,7 @@ func (Implementation) Dtbmv(ul blas.Uplo, tA blas.Transpose, d blas.Diag, n int,
 	if lda*(n-1)+k+1 > len(a) || lda < k+1 {
 		panic("blas: index of a out of range")
 	}
-	C.cblas_dtbmv(C.enum_CBLAS_ORDER(rowMajor), C.enum_CBLAS_UPLO(ul), C.enum_CBLAS_TRANSPOSE(tA), C.enum_CBLAS_DIAG(d), C.int(n), C.int(k), (*C.double)(&a[0]), C.int(lda), (*C.double)(&x[0]), C.int(incX))
+	C.cblas_dtbmv(C.enum_CBLAS_ORDER(rowMajor), C.enum_CBLAS_UPLO(ul), C.enum_CBLAS_TRANSPOSE(tA), C.enum_CBLAS_DIAG(d), C.blasint(n), C.blasint(k), (*C.double)(&a[0]), C.blasint(lda), (*C.double)(&x[0]), C.blasint(incX))
 }
 func (Implementation) Dtpmv(ul blas.Uplo, tA blas.Transpose, d blas.Diag, n int, ap []float64, x []float64, incX int) {
 	if ul != blas.Upper && ul != blas.Lower {
@@ -1159,7 +1159,7 @@ func (Implementation) Dtpmv(ul blas.Uplo, tA blas.Transpose, d blas.Diag, n int,
 	if (incX > 0 && (n-1)*incX >= len(x)) || (incX < 0 && (1-n)*incX >= len(x)) {
 		panic("blas: x index out of range")
 	}
-	C.cblas_dtpmv(C.enum_CBLAS_ORDER(rowMajor), C.enum_CBLAS_UPLO(ul), C.enum_CBLAS_TRANSPOSE(tA), C.enum_CBLAS_DIAG(d), C.int(n), (*C.double)(&ap[0]), (*C.double)(&x[0]), C.int(incX))
+	C.cblas_dtpmv(C.enum_CBLAS_ORDER(rowMajor), C.enum_CBLAS_UPLO(ul), C.enum_CBLAS_TRANSPOSE(tA), C.enum_CBLAS_DIAG(d), C.blasint(n), (*C.double)(&ap[0]), (*C.double)(&x[0]), C.blasint(incX))
 }
 func (Implementation) Dtrsv(ul blas.Uplo, tA blas.Transpose, d blas.Diag, n int, a []float64, lda int, x []float64, incX int) {
 	if ul != blas.Upper && ul != blas.Lower {
@@ -1183,7 +1183,7 @@ func (Implementation) Dtrsv(ul blas.Uplo, tA blas.Transpose, d blas.Diag, n int,
 	if lda*(n-1)+n > len(a) || lda < max(1, n) {
 		panic("blas: index of a out of range")
 	}
-	C.cblas_dtrsv(C.enum_CBLAS_ORDER(rowMajor), C.enum_CBLAS_UPLO(ul), C.enum_CBLAS_TRANSPOSE(tA), C.enum_CBLAS_DIAG(d), C.int(n), (*C.double)(&a[0]), C.int(lda), (*C.double)(&x[0]), C.int(incX))
+	C.cblas_dtrsv(C.enum_CBLAS_ORDER(rowMajor), C.enum_CBLAS_UPLO(ul), C.enum_CBLAS_TRANSPOSE(tA), C.enum_CBLAS_DIAG(d), C.blasint(n), (*C.double)(&a[0]), C.blasint(lda), (*C.double)(&x[0]), C.blasint(incX))
 }
 func (Implementation) Dtbsv(ul blas.Uplo, tA blas.Transpose, d blas.Diag, n int, k int, a []float64, lda int, x []float64, incX int) {
 	if ul != blas.Upper && ul != blas.Lower {
@@ -1210,7 +1210,7 @@ func (Implementation) Dtbsv(ul blas.Uplo, tA blas.Transpose, d blas.Diag, n int,
 	if lda*(n-1)+k+1 > len(a) || lda < k+1 {
 		panic("blas: index of a out of range")
 	}
-	C.cblas_dtbsv(C.enum_CBLAS_ORDER(rowMajor), C.enum_CBLAS_UPLO(ul), C.enum_CBLAS_TRANSPOSE(tA), C.enum_CBLAS_DIAG(d), C.int(n), C.int(k), (*C.double)(&a[0]), C.int(lda), (*C.double)(&x[0]), C.int(incX))
+	C.cblas_dtbsv(C.enum_CBLAS_ORDER(rowMajor), C.enum_CBLAS_UPLO(ul), C.enum_CBLAS_TRANSPOSE(tA), C.enum_CBLAS_DIAG(d), C.blasint(n), C.blasint(k), (*C.double)(&a[0]), C.blasint(lda), (*C.double)(&x[0]), C.blasint(incX))
 }
 func (Implementation) Dtpsv(ul blas.Uplo, tA blas.Transpose, d blas.Diag, n int, ap []float64, x []float64, incX int) {
 	if ul != blas.Upper && ul != blas.Lower {
@@ -1234,7 +1234,7 @@ func (Implementation) Dtpsv(ul blas.Uplo, tA blas.Transpose, d blas.Diag, n int,
 	if (incX > 0 && (n-1)*incX >= len(x)) || (incX < 0 && (1-n)*incX >= len(x)) {
 		panic("blas: x index out of range")
 	}
-	C.cblas_dtpsv(C.enum_CBLAS_ORDER(rowMajor), C.enum_CBLAS_UPLO(ul), C.enum_CBLAS_TRANSPOSE(tA), C.enum_CBLAS_DIAG(d), C.int(n), (*C.double)(&ap[0]), (*C.double)(&x[0]), C.int(incX))
+	C.cblas_dtpsv(C.enum_CBLAS_ORDER(rowMajor), C.enum_CBLAS_UPLO(ul), C.enum_CBLAS_TRANSPOSE(tA), C.enum_CBLAS_DIAG(d), C.blasint(n), (*C.double)(&ap[0]), (*C.double)(&x[0]), C.blasint(incX))
 }
 func (Implementation) Cgemv(tA blas.Transpose, m int, n int, alpha complex64, a []complex64, lda int, x []complex64, incX int, beta complex64, y []complex64, incY int) {
 	if tA != blas.NoTrans && tA != blas.Trans && tA != blas.ConjTrans {
@@ -1267,7 +1267,7 @@ func (Implementation) Cgemv(tA blas.Transpose, m int, n int, alpha complex64, a
 	if lda*(m-1)+n > len(a) || lda < max(1, n) {
 		panic("blas: index of a out of range")
 	}
-	C.cblas_cgemv(C.enum_CBLAS_ORDER(rowMajor), C.enum_CBLAS_TRANSPOSE(tA), C.int(m), C.int(n), unsafe.Pointer(&alpha), unsafe.Pointer(&a[0]), C.int(lda), unsafe.Pointer(&x[0]), C.int(incX), unsafe.Pointer(&beta), unsafe.Pointer(&y[0]), C.int(incY))
+	C.cblas_cgemv(C.enum_CBLAS_ORDER(rowMajor), C.enum_CBLAS_TRANSPOSE(tA), C.blasint(m), C.blasint(n), unsafe.Pointer(&alpha), unsafe.Pointer(&a[0]), C.blasint(lda), unsafe.Pointer(&x[0]), C.blasint(incX), unsafe.Pointer(&beta), unsafe.Pointer(&y[0]), C.blasint(incY))
 }
 func (Implementation) Cgbmv(tA blas.Transpose, m int, n int, kL int, kU int, alpha complex64, a []complex64, lda int, x []complex64, incX int, beta complex64, y []complex64, incY int) {
 	if tA != blas.NoTrans && tA != blas.Trans && tA != blas.ConjTrans {
@@ -1306,7 +1306,7 @@ func (Implementation) Cgbmv(tA blas.Transpose, m int, n int, kL int, kU int, alp
 	if lda*(m-1)+kL+kU+1 > len(a) || lda < kL+kU+1 {
 		panic("blas: index of a out of range")
 	}
-	C.cblas_cgbmv(C.enum_CBLAS_ORDER(rowMajor), C.enum_CBLAS_TRANSPOSE(tA), C.int(m), C.int(n), C.int(kL), C.int(kU), unsafe.Pointer(&alpha), unsafe.Pointer(&a[0]), C.int(lda), unsafe.Pointer(&x[0]), C.int(incX), unsafe.Pointer(&beta), unsafe.Pointer(&y[0]), C.int(incY))
+	C.cblas_cgbmv(C.enum_CBLAS_ORDER(rowMajor), C.enum_CBLAS_TRANSPOSE(tA), C.blasint(m), C.blasint(n), C.blasint(kL), C.blasint(kU), unsafe.Pointer(&alpha), unsafe.Pointer(&a[0]), C.blasint(lda), unsafe.Pointer(&x[0]), C.blasint(incX), unsafe.Pointer(&beta), unsafe.Pointer(&y[0]), C.blasint(incY))
 }
 func (Implementation) Ctrmv(ul blas.Uplo, tA blas.Transpose, d blas.Diag, n int, a []complex64, lda int, x []complex64, incX int) {
 	if ul != blas.Upper && ul != blas.Lower {
@@ -1330,7 +1330,7 @@ func (Implementation) Ctrmv(ul blas.Uplo, tA blas.Transpose, d blas.Diag, n int,
 	if lda*(n-1)+n > len(a) || lda < max(1, n) {
 		panic("blas: index of a out of range")
 	}
-	C.cblas_ctrmv(C.enum_CBLAS_ORDER(rowMajor), C.enum_CBLAS_UPLO(ul), C.enum_CBLAS_TRANSPOSE(tA), C.enum_CBLAS_DIAG(d), C.int(n), unsafe.Pointer(&a[0]), C.int(lda), unsafe.Pointer(&x[0]), C.int(incX))
+	C.cblas_ctrmv(C.enum_CBLAS_ORDER(rowMajor), C.enum_CBLAS_UPLO(ul), C.enum_CBLAS_TRANSPOSE(tA), C.enum_CBLAS_DIAG(d), C.blasint(n), unsafe.Pointer(&a[0]), C.blasint(lda), unsafe.Pointer(&x[0]), C.blasint(incX))
 }
 func (Implementation) Ctbmv(ul blas.Uplo, tA blas.Transpose, d blas.Diag, n int, k int, a []complex64, lda int, x []complex64, incX int) {
 	if ul != blas.Upper && ul != blas.Lower {
@@ -1357,7 +1357,7 @@ func (Implementation) Ctbmv(ul blas.Uplo, tA blas.Transpose, d blas.Diag, n int,
 	if lda*(n-1)+k+1 > len(a) || lda < k+1 {
 		panic("blas: index of a out of range")
 	}
-	C.cblas_ctbmv(C.enum_CBLAS_ORDER(rowMajor), C.enum_CBLAS_UPLO(ul), C.enum_CBLAS_TRANSPOSE(tA), C.enum_CBLAS_DIAG(d), C.int(n), C.int(k), unsafe.Pointer(&a[0]), C.int(lda), unsafe.Pointer(&x[0]), C.int(incX))
+	C.cblas_ctbmv(C.enum_CBLAS_ORDER(rowMajor), C.enum_CBLAS_UPLO(ul), C.enum_CBLAS_TRANSPOSE(tA), C.enum_CBLAS_DIAG(d), C.blasint(n), C.blasint(k), unsafe.Pointer(&a[0]), C.blasint(lda), unsafe.Pointer(&x[0]), C.blasint(incX))
 }
 func (Implementation) Ctpmv(ul blas.Uplo, tA blas.Transpose, d blas.Diag, n int, ap []complex64, x []complex64, incX int) {
 	if ul != blas.Upper && ul != blas.Lower {
@@ -1381,7 +1381,7 @@ func (Implementation) Ctpmv(ul blas.Uplo, tA blas.Transpose, d blas.Diag, n int,
 	if (incX > 0 && (n-1)*incX >= len(x)) || (incX < 0 && (1-n)*incX >= len(x)) {
 		panic("blas: x index out of range")
 	}
-	C.cblas_ctpmv(C.enum_CBLAS_ORDER(rowMajor), C.enum_CBLAS_UPLO(ul), C.enum_CBLAS_TRANSPOSE(tA), C.enum_CBLAS_DIAG(d), C.int(n), unsafe.Pointer(&ap[0]), unsafe.Pointer(&x[0]), C.int(incX))
+	C.cblas_ctpmv(C.enum_CBLAS_ORDER(rowMajor), C.enum_CBLAS_UPLO(ul), C.enum_CBLAS_TRANSPOSE(tA), C.enum_CBLAS_DIAG(d), C.blasint(n), unsafe.Pointer(&ap[0]), unsafe.Pointer(&x[0]), C.blasint(incX))
 }
 func (Implementation) Ctrsv(ul blas.Uplo, tA blas.Transpose, d blas.Diag, n int, a []complex64, lda int, x []complex64, incX int) {
 	if ul != blas.Upper && ul != blas.Lower {
@@ -1405,7 +1405,7 @@ func (Implementation) Ctrsv(ul blas.Uplo, tA blas.Transpose, d blas.Diag, n int,
 	if lda*(n-1)+n > len(a) || lda < max(1, n) {
 		panic("blas: index of a out of range")
 	}
-	C.cblas_ctrsv(C.enum_CBLAS_ORDER(rowMajor), C.enum_CBLAS_UPLO(ul), C.enum_CBLAS_TRANSPOSE(tA), C.enum_CBLAS_DIAG(d), C.int(n), unsafe.Pointer(&a[0]), C.int(lda), unsafe.Pointer(&x[0]), C.int(incX))
+	C.cblas_ctrsv(C.enum_CBLAS_ORDER(rowMajor), C.enum_CBLAS_UPLO(ul), C.enum_CBLAS_TRANSPOSE(tA), C.enum_CBLAS_DIAG(d), C.blasint(n), unsafe.Pointer(&a[0]), C.blasint(lda), unsafe.Pointer(&x[0]), C.blasint(incX))
 }
 func (Implementation) Ctbsv(ul blas.Uplo, tA blas.Transpose, d blas.Diag, n int, k int, a []complex64, lda int, x []complex64, incX int) {
 	if ul != blas.Upper && ul != blas.Lower {
@@ -1432,7 +1432,7 @@ func (Implementation) Ctbsv(ul blas.Uplo, tA blas.Transpose, d blas.Diag, n int,
 	if lda*(n-1)+k+1 > len(a) || lda < k+1 {
 		panic("blas: index of a out of range")
 	}
-	C.cblas_ctbsv(C.enum_CBLAS_ORDER(rowMajor), C.enum_CBLAS_UPLO(ul), C.enum_CBLAS_TRANSPOSE(tA), C.enum_CBLAS_DIAG(d), C.int(n), C.int(k), unsafe.Pointer(&a[0]), C.int(lda), unsafe.Pointer(&x[0]), C.int(incX))
+	C.cblas_ctbsv(C.enum_CBLAS_ORDER(rowMajor), C.enum_CBLAS_UPLO(ul), C.enum_CBLAS_TRANSPOSE(tA), C.enum_CBLAS_DIAG(d), C.blasint(n), C.blasint(k), unsafe.Pointer(&a[0]), C.blasint(lda), unsafe.Pointer(&x[0]), C.blasint(incX))
 }
 func (Implementation) Ctpsv(ul blas.Uplo, tA blas.Transpose, d blas.Diag, n int, ap []complex64, x []complex64, incX int) {
 	if ul != blas.Upper && ul != blas.Lower {
@@ -1456,7 +1456,7 @@ func (Implementation) Ctpsv(ul blas.Uplo, tA blas.Transpose, d blas.Diag, n int,
 	if (incX > 0 && (n-1)*incX >= len(x)) || (incX < 0 && (1-n)*incX >= len(x)) {
 		panic("blas: x index out of range")
 	}
-	C.cblas_ctpsv(C.enum_CBLAS_ORDER(rowMajor), C.enum_CBLAS_UPLO(ul), C.enum_CBLAS_TRANSPOSE(tA), C.enum_CBLAS_DIAG(d), C.int(n), unsafe.Pointer(&ap[0]), unsafe.Pointer(&x[0]), C.int(incX))
+	C.cblas_ctpsv(C.enum_CBLAS_ORDER(rowMajor), C.enum_CBLAS_UPLO(ul), C.enum_CBLAS_TRANSPOSE(tA), C.enum_CBLAS_DIAG(d), C.blasint(n), unsafe.Pointer(&ap[0]), unsafe.Pointer(&x[0]), C.blasint(incX))
 }
 func (Implementation) Zgemv(tA blas.Transpose, m int, n int, alpha complex128, a []complex128, lda int, x []complex128, incX int, beta complex128, y []complex128, incY int) {
 	if tA != blas.NoTrans && tA != blas.Trans && tA != blas.ConjTrans {
@@ -1489,7 +1489,7 @@ func (Implementation) Zgemv(tA blas.Transpose, m int, n int, alpha complex128, a
 	if lda*(m-1)+n > len(a) || lda < max(1, n) {
 		panic("blas: index of a out of range")
 	}
-	C.cblas_zgemv(C.enum_CBLAS_ORDER(rowMajor), C.enum_CBLAS_TRANSPOSE(tA), C.int(m), C.int(n), unsafe.Pointer(&alpha), unsafe.Pointer(&a[0]), C.int(lda), unsafe.Pointer(&x[0]), C.int(incX), unsafe.Pointer(&beta), unsafe.Pointer(&y[0]), C.int(incY))
+	C.cblas_zgemv(C.enum_CBLAS_ORDER(rowMajor), C.enum_CBLAS_TRANSPOSE(tA), C.blasint(m), C.blasint(n), unsafe.Pointer(&alpha), unsafe.Pointer(&a[0]), C.blasint(lda), unsafe.Pointer(&x[0]), C.blasint(incX), unsafe.Pointer(&beta), unsafe.Pointer(&y[0]), C.blasint(incY))
 }
 func (Implementation) Zgbmv(tA blas.Transpose, m int, n int, kL int, kU int, alpha complex128, a []complex128, lda int, x []complex128, incX int, beta complex128, y []complex128, incY int) {
 	if tA != blas.NoTrans && tA != blas.Trans && tA != blas.ConjTrans {
@@ -1528,7 +1528,7 @@ func (Implementation) Zgbmv(tA blas.Transpose, m int, n int, kL int, kU int, alp
 	if lda*(m-1)+kL+kU+1 > len(a) || lda < kL+kU+1 {
 		panic("blas: index of a out of range")
 	}
-	C.cblas_zgbmv(C.enum_CBLAS_ORDER(rowMajor), C.enum_CBLAS_TRANSPOSE(tA), C.int(m), C.int(n), C.int(kL), C.int(kU), unsafe.Pointer(&alpha), unsafe.Pointer(&a[0]), C.int(lda), unsafe.Pointer(&x[0]), C.int(incX), unsafe.Pointer(&beta), unsafe.Pointer(&y[0]), C.int(incY))
+	C.cblas_zgbmv(C.enum_CBLAS_ORDER(rowMajor), C.enum_CBLAS_TRANSPOSE(tA), C.blasint(m), C.blasint(n), C.blasint(kL), C.blasint(kU), unsafe.Pointer(&alpha), unsafe.Pointer(&a[0]), C.blasint(lda), unsafe.Pointer(&x[0]), C.blasint(incX), unsafe.Pointer(&beta), unsafe.Pointer(&y[0]), C.blasint(incY))
 }
 func (Implementation) Ztrmv(ul blas.Uplo, tA blas.Transpose, d blas.Diag, n int, a []complex128, lda int, x []complex128, incX int) {
 	if ul != blas.Upper && ul != blas.Lower {
@@ -1552,7 +1552,7 @@ func (Implementation) Ztrmv(ul blas.Uplo, tA blas.Transpose, d blas.Diag, n int,
 	if lda*(n-1)+n > len(a) || lda < max(1, n) {
 		panic("blas: index of a out of range")
 	}
-	C.cblas_ztrmv(C.enum_CBLAS_ORDER(rowMajor), C.enum_CBLAS_UPLO(ul), C.enum_CBLAS_TRANSPOSE(tA), C.enum_CBLAS_DIAG(d), C.int(n), unsafe.Pointer(&a[0]), C.int(lda), unsafe.Pointer(&x[0]), C.int(incX))
+	C.cblas_ztrmv(C.enum_CBLAS_ORDER(rowMajor), C.enum_CBLAS_UPLO(ul), C.enum_CBLAS_TRANSPOSE(tA), C.enum_CBLAS_DIAG(d), C.blasint(n), unsafe.Pointer(&a[0]), C.blasint(lda), unsafe.Pointer(&x[0]), C.blasint(incX))
 }
 func (Implementation) Ztbmv(ul blas.Uplo, tA blas.Transpose, d blas.Diag, n int, k int, a []complex128, lda int, x []complex128, incX int) {
 	if ul != blas.Upper && ul != blas.Lower {
@@ -1579,7 +1579,7 @@ func (Implementation) Ztbmv(ul blas.Uplo, tA blas.Transpose, d blas.Diag, n int,
 	if lda*(n-1)+k+1 > len(a) || lda < k+1 {
 		panic("blas: index of a out of range")
 	}
-	C.cblas_ztbmv(C.enum_CBLAS_ORDER(rowMajor), C.enum_CBLAS_UPLO(ul), C.enum_CBLAS_TRANSPOSE(tA), C.enum_CBLAS_DIAG(d), C.int(n), C.int(k), unsafe.Pointer(&a[0]), C.int(lda), unsafe.Pointer(&x[0]), C.int(incX))
+	C.cblas_ztbmv(C.enum_CBLAS_ORDER(rowMajor), C.enum_CBLAS_UPLO(ul), C.enum_CBLAS_TRANSPOSE(tA), C.enum_CBLAS_DIAG(d), C.blasint(n), C.blasint(k), unsafe.Pointer(&a[0]), C.blasint(lda), unsafe.Pointer(&x[0]), C.blasint(incX))
 }
 func (Implementation) Ztpmv(ul blas.Uplo, tA blas.Transpose, d blas.Diag, n int, ap []complex128, x []complex128, incX int) {
 	if ul != blas.Upper && ul != blas.Lower {
@@ -1603,7 +1603,7 @@ func (Implementation) Ztpmv(ul blas.Uplo, tA blas.Transpose, d blas.Diag, n int,
 	if (incX > 0 && (n-1)*incX >= len(x)) || (incX < 0 && (1-n)*incX >= len(x)) {
 		panic("blas: x index out of range")
 	}
-	C.cblas_ztpmv(C.enum_CBLAS_ORDER(rowMajor), C.enum_CBLAS_UPLO(ul), C.enum_CBLAS_TRANSPOSE(tA), C.enum_CBLAS_DIAG(d), C.int(n), unsafe.Pointer(&ap[0]), unsafe.Pointer(&x[0]), C.int(incX))
+	C.cblas_ztpmv(C.enum_CBLAS_ORDER(rowMajor), C.enum_CBLAS_UPLO(ul), C.enum_CBLAS_TRANSPOSE(tA), C.enum_CBLAS_DIAG(d), C.blasint(n), unsafe.Pointer(&ap[0]), unsafe.Pointer(&x[0]), C.blasint(incX))
 }
 func (Implementation) Ztrsv(ul blas.Uplo, tA blas.Transpose, d blas.Diag, n int, a []complex128, lda int, x []complex128, incX int) {
 	if ul != blas.Upper && ul != blas.Lower {
@@ -1627,7 +1627,7 @@ func (Implementation) Ztrsv(ul blas.Uplo, tA blas.Transpose, d blas.Diag, n int,
 	if lda*(n-1)+n > len(a) || lda < max(1, n) {
 		panic("blas: index of a out of range")
 	}
-	C.cblas_ztrsv(C.enum_CBLAS_ORDER(rowMajor), C.enum_CBLAS_UPLO(ul), C.enum_CBLAS_TRANSPOSE(tA), C.enum_CBLAS_DIAG(d), C.int(n), unsafe.Pointer(&a[0]), C.int(lda), unsafe.Pointer(&x[0]), C.int(incX))
+	C.cblas_ztrsv(C.enum_CBLAS_ORDER(rowMajor), C.enum_CBLAS_UPLO(ul), C.enum_CBLAS_TRANSPOSE(tA), C.enum_CBLAS_DIAG(d), C.blasint(n), unsafe.Pointer(&a[0]), C.blasint(lda), unsafe.Pointer(&x[0]), C.blasint(incX))
 }
 func (Implementation) Ztbsv(ul blas.Uplo, tA blas.Transpose, d blas.Diag, n int, k int, a []complex128, lda int, x []complex128, incX int) {
 	if ul != blas.Upper && ul != blas.Lower {
@@ -1654,7 +1654,7 @@ func (Implementation) Ztbsv(ul blas.Uplo, tA blas.Transpose, d blas.Diag, n int,
 	if lda*(n-1)+k+1 > len(a) || lda < k+1 {
 		panic("blas: index of a out of range")
 	}
-	C.cblas_ztbsv(C.enum_CBLAS_ORDER(rowMajor), C.enum_CBLAS_UPLO(ul), C.enum_CBLAS_TRANSPOSE(tA), C.enum_CBLAS_DIAG(d), C.int(n), C.int(k), unsafe.Pointer(&a[0]), C.int(lda), unsafe.Pointer(&x[0]), C.int(incX))
+	C.cblas_ztbsv(C.enum_CBLAS_ORDER(rowMajor), C.enum_CBLAS_UPLO(ul), C.enum_CBLAS_TRANSPOSE(tA), C.enum_CBLAS_DIAG(d), C.blasint(n), C.blasint(k), unsafe.Pointer(&a[0]), C.blasint(lda), unsafe.Pointer(&x[0]), C.blasint(incX))
 }
 func (Implementation) Ztpsv(ul blas.Uplo, tA blas.Transpose, d blas.Diag, n int, ap []complex128, x []complex128, incX int) {
 	if ul != blas.Upper && ul != blas.Lower {
@@ -1678,7 +1678,7 @@ func (Implementation) Ztpsv(ul blas.Uplo, tA blas.Transpose, d blas.Diag, n int,
 	if (incX > 0 && (n-1)*incX >= len(x)) || (incX < 0 && (1-n)*incX >= len(x)) {
 		panic("blas: x index out of range")
 	}
-	C.cblas_ztpsv(C.enum_CBLAS_ORDER(rowMajor), C.enum_CBLAS_UPLO(ul), C.enum_CBLAS_TRANSPOSE(tA), C.enum_CBLAS_DIAG(d), C.int(n), unsafe.Pointer(&ap[0]), unsafe.Pointer(&x[0]), C.int(incX))
+	C.cblas_ztpsv(C.enum_CBLAS_ORDER(rowMajor), C.enum_CBLAS_UPLO(ul), C.enum_CBLAS_TRANSPOSE(tA), C.enum_CBLAS_DIAG(d), C.blasint(n), unsafe.Pointer(&ap[0]), unsafe.Pointer(&x[0]), C.blasint(incX))
 }
 func (Implementation) Ssymv(ul blas.Uplo, n int, alpha float32, a []float32, lda int, x []float32, incX int, beta float32, y []float32, incY int) {
 	if ul != blas.Upper && ul != blas.Lower {
@@ -1702,7 +1702,7 @@ func (Implementation) Ssymv(ul blas.Uplo, n int, alpha float32, a []float32, lda
 	if lda*(n-1)+n > len(a) || lda < max(1, n) {
 		panic("blas: index of a out of range")
 	}
-	C.cblas_ssymv(C.enum_CBLAS_ORDER(rowMajor), C.enum_CBLAS_UPLO(ul), C.int(n), C.float(alpha), (*C.float)(&a[0]), C.int(lda), (*C.float)(&x[0]), C.int(incX), C.float(beta), (*C.float)(&y[0]), C.int(incY))
+	C.cblas_ssymv(C.enum_CBLAS_ORDER(rowMajor), C.enum_CBLAS_UPLO(ul), C.blasint(n), C.float(alpha), (*C.float)(&a[0]), C.blasint(lda), (*C.float)(&x[0]), C.blasint(incX), C.float(beta), (*C.float)(&y[0]), C.blasint(incY))
 }
 func (Implementation) Ssbmv(ul blas.Uplo, n int, k int, alpha float32, a []float32, lda int, x []float32, incX int, beta float32, y []float32, incY int) {
 	if ul != blas.Upper && ul != blas.Lower {
@@ -1729,7 +1729,7 @@ func (Implementation) Ssbmv(ul blas.Uplo, n int, k int, alpha float32, a []float
 	if lda*(n-1)+k+1 > len(a) || lda < k+1 {
 		panic("blas: index of a out of range")
 	}
-	C.cblas_ssbmv(C.enum_CBLAS_ORDER(rowMajor), C.enum_CBLAS_UPLO(ul), C.int(n), C.int(k), C.float(alpha), (*C.float)(&a[0]), C.int(lda), (*C.float)(&x[0]), C.int(incX), C.float(beta), (*C.float)(&y[0]), C.int(incY))
+	C.cblas_ssbmv(C.enum_CBLAS_ORDER(rowMajor), C.enum_CBLAS_UPLO(ul), C.blasint(n), C.blasint(k), C.float(alpha), (*C.float)(&a[0]), C.blasint(lda), (*C.float)(&x[0]), C.blasint(incX), C.float(beta), (*C.float)(&y[0]), C.blasint(incY))
 }
 func (Implementation) Sspmv(ul blas.Uplo, n int, alpha float32, ap []float32, x []float32, incX int, beta float32, y []float32, incY int) {
 	if ul != blas.Upper && ul != blas.Lower {
@@ -1753,7 +1753,7 @@ func (Implementation) Sspmv(ul blas.Uplo, n int, alpha float32, ap []float32, x
 	if (incY > 0 && (n-1)*incY >= len(y)) || (incY < 0 && (1-n)*incY >= len(y)) {
 		panic("blas: y index out of range")
 	}
-	C.cblas_sspmv(C.enum_CBLAS_ORDER(rowMajor), C.enum_CBLAS_UPLO(ul), C.int(n), C.float(alpha), (*C.float)(&ap[0]), (*C.float)(&x[0]), C.int(incX), C.float(beta), (*C.float)(&y[0]), C.int(incY))
+	C.cblas_sspmv(C.enum_CBLAS_ORDER(rowMajor), C.enum_CBLAS_UPLO(ul), C.blasint(n), C.float(alpha), (*C.float)(&ap[0]), (*C.float)(&x[0]), C.blasint(incX), C.float(beta), (*C.float)(&y[0]), C.blasint(incY))
 }
 func (Implementation) Sger(m int, n int, alpha float32, x []float32, incX int, y []float32, incY int, a []float32, lda int) {
 	if m < 0 {
@@ -1777,7 +1777,7 @@ func (Implementation) Sger(m int, n int, alpha float32, x []float32, incX int, y
 	if lda*(m-1)+n > len(a) || lda < max(1, n) {
 		panic("blas: index of a out of range")
 	}
-	C.cblas_sger(C.enum_CBLAS_ORDER(rowMajor), C.int(m), C.int(n), C.float(alpha), (*C.float)(&x[0]), C.int(incX), (*C.float)(&y[0]), C.int(incY), (*C.float)(&a[0]), C.int(lda))
+	C.cblas_sger(C.enum_CBLAS_ORDER(rowMajor), C.blasint(m), C.blasint(n), C.float(alpha), (*C.float)(&x[0]), C.blasint(incX), (*C.float)(&y[0]), C.blasint(incY), (*C.float)(&a[0]), C.blasint(lda))
 }
 func (Implementation) Ssyr(ul blas.Uplo, n int, alpha float32, x []float32, incX int, a []float32, lda int) {
 	if ul != blas.Upper && ul != blas.Lower {
@@ -1795,7 +1795,7 @@ func (Implementation) Ssyr(ul blas.Uplo, n int, alpha float32, x []float32, incX
 	if lda*(n-1)+n > len(a) || lda < max(1, n) {
 		panic("blas: index of a out of range")
 	}
-	C.cblas_ssyr(C.enum_CBLAS_ORDER(rowMajor), C.enum_CBLAS_UPLO(ul), C.int(n), C.float(alpha), (*C.float)(&x[0]), C.int(incX), (*C.float)(&a[0]), C.int(lda))
+	C.cblas_ssyr(C.enum_CBLAS_ORDER(rowMajor), C.enum_CBLAS_UPLO(ul), C.blasint(n), C.float(alpha), (*C.float)(&x[0]), C.blasint(incX), (*C.float)(&a[0]), C.blasint(lda))
 }
 func (Implementation) Sspr(ul blas.Uplo, n int, alpha float32, x []float32, incX int, ap []float32) {
 	if ul != blas.Upper && ul != blas.Lower {
@@ -1813,7 +1813,7 @@ func (Implementation) Sspr(ul blas.Uplo, n int, alpha float32, x []float32, incX
 	if (incX > 0 && (n-1)*incX >= len(x)) || (incX < 0 && (1-n)*incX >= len(x)) {
 		panic("blas: x index out of range")
 	}
-	C.cblas_sspr(C.enum_CBLAS_ORDER(rowMajor), C.enum_CBLAS_UPLO(ul), C.int(n), C.float(alpha), (*C.float)(&x[0]), C.int(incX), (*C.float)(&ap[0]))
+	C.cblas_sspr(C.enum_CBLAS_ORDER(rowMajor), C.enum_CBLAS_UPLO(ul), C.blasint(n), C.float(alpha), (*C.float)(&x[0]), C.blasint(incX), (*C.float)(&ap[0]))
 }
 func (Implementation) Ssyr2(ul blas.Uplo, n int, alpha float32, x []float32, incX int, y []float32, incY int, a []float32, lda int) {
 	if ul != blas.Upper && ul != blas.Lower {
@@ -1837,7 +1837,7 @@ func (Implementation) Ssyr2(ul blas.Uplo, n int, alpha float32, x []float32, inc
 	if lda*(n-1)+n > len(a) || lda < max(1, n) {
 		panic("blas: index of a out of range")
 	}
-	C.cblas_ssyr2(C.enum_CBLAS_ORDER(rowMajor), C.enum_CBLAS_UPLO(ul), C.int(n), C.float(alpha), (*C.float)(&x[0]), C.int(incX), (*C.float)(&y[0]), C.int(incY), (*C.float)(&a[0]), C.int(lda))
+	C.cblas_ssyr2(C.enum_CBLAS_ORDER(rowMajor), C.enum_CBLAS_UPLO(ul), C.blasint(n), C.float(alpha), (*C.float)(&x[0]), C.blasint(incX), (*C.float)(&y[0]), C.blasint(incY), (*C.float)(&a[0]), C.blasint(lda))
 }
 func (Implementation) Sspr2(ul blas.Uplo, n int, alpha float32, x []float32, incX int, y []float32, incY int, ap []float32) {
 	if ul != blas.Upper && ul != blas.Lower {
@@ -1861,7 +1861,7 @@ func (Implementation) Sspr2(ul blas.Uplo, n int, alpha float32, x []float32, inc
 	if (incY > 0 && (n-1)*incY >= len(y)) || (incY < 0 && (1-n)*incY >= len(y)) {
 		panic("blas: y index out of range")
 	}
-	C.cblas_sspr2(C.enum_CBLAS_ORDER(rowMajor), C.enum_CBLAS_UPLO(ul), C.int(n), C.float(alpha), (*C.float)(&x[0]), C.int(incX), (*C.float)(&y[0]), C.int(incY), (*C.float)(&ap[0]))
+	C.cblas_sspr2(C.enum_CBLAS_ORDER(rowMajor), C.enum_CBLAS_UPLO(ul), C.blasint(n), C.float(alpha), (*C.float)(&x[0]), C.blasint(incX), (*C.float)(&y[0]), C.blasint(incY), (*C.float)(&ap[0]))
 }
 func (Implementation) Dsymv(ul blas.Uplo, n int, alpha float64, a []float64, lda int, x []float64, incX int, beta float64, y []float64, incY int) {
 	if ul != blas.Upper && ul != blas.Lower {
@@ -1885,7 +1885,7 @@ func (Implementation) Dsymv(ul blas.Uplo, n int, alpha float64, a []float64, lda
 	if lda*(n-1)+n > len(a) || lda < max(1, n) {
 		panic("blas: index of a out of range")
 	}
-	C.cblas_dsymv(C.enum_CBLAS_ORDER(rowMajor), C.enum_CBLAS_UPLO(ul), C.int(n), C.double(alpha), (*C.double)(&a[0]), C.int(lda), (*C.double)(&x[0]), C.int(incX), C.double(beta), (*C.double)(&y[0]), C.int(incY))
+	C.cblas_dsymv(C.enum_CBLAS_ORDER(rowMajor), C.enum_CBLAS_UPLO(ul), C.blasint(n), C.double(alpha), (*C.double)(&a[0]), C.blasint(lda), (*C.double)(&x[0]), C.blasint(incX), C.double(beta), (*C.double)(&y[0]), C.blasint(incY))
 }
 func (Implementation) Dsbmv(ul blas.Uplo, n int, k int, alpha float64, a []float64, lda int, x []float64, incX int, beta float64, y []float64, incY int) {
 	if ul != blas.Upper && ul != blas.Lower {
@@ -1912,7 +1912,7 @@ func (Implementation) Dsbmv(ul blas.Uplo, n int, k int, alpha float64, a []float
 	if lda*(n-1)+k+1 > len(a) || lda < k+1 {
 		panic("blas: index of a out of range")
 	}
-	C.cblas_dsbmv(C.enum_CBLAS_ORDER(rowMajor), C.enum_CBLAS_UPLO(ul), C.int(n), C.int(k), C.double(alpha), (*C.double)(&a[0]), C.int(lda), (*C.double)(&x[0]), C.int(incX), C.double(beta), (*C.double)(&y[0]), C.int(incY))
+	C.cblas_dsbmv(C.enum_CBLAS_ORDER(rowMajor), C.enum_CBLAS_UPLO(ul), C.blasint(n), C.blasint(k), C.double(alpha), (*C.double)(&a[0]), C.blasint(lda), (*C.double)(&x[0]), C.blasint(incX), C.double(beta), (*C.double)(&y[0]), C.blasint(incY))
 }
 func (Implementation) Dspmv(ul blas.Uplo, n int, alpha float64, ap []float64, x []float64, incX int, beta float64, y []float64, incY int) {
 	if ul != blas.Upper && ul != blas.Lower {
@@ -1936,7 +1936,7 @@ func (Implementation) Dspmv(ul blas.Uplo, n int, alpha float64, ap []float64, x
 	if (incY > 0 && (n-1)*incY >= len(y)) || (incY < 0 && (1-n)*incY >= len(y)) {
 		panic("blas: y index out of range")
 	}
-	C.cblas_dspmv(C.enum_CBLAS_ORDER(rowMajor), C.enum_CBLAS_UPLO(ul), C.int(n), C.double(alpha), (*C.double)(&ap[0]), (*C.double)(&x[0]), C.int(incX), C.double(beta), (*C.double)(&y[0]), C.int(incY))
+	C.cblas_dspmv(C.enum_CBLAS_ORDER(rowMajor), C.enum_CBLAS_UPLO(ul), C.blasint(n), C.double(alpha), (*C.double)(&ap[0]), (*C.double)(&x[0]), C.blasint(incX), C.double(beta), (*C.double)(&y[0]), C.blasint(incY))
 }
 func (Implementation) Dger(m int, n int, alpha float64, x []float64, incX int, y []float64, incY int, a []float64, lda int) {
 	if m < 0 {
@@ -1960,7 +1960,7 @@ func (Implementation) Dger(m int, n int, alpha float64, x []float64, incX int, y
 	if lda*(m-1)+n > len(a) || lda < max(1, n) {
 		panic("blas: index of a out of range")
 	}
-	C.cblas_dger(C.enum_CBLAS_ORDER(rowMajor), C.int(m), C.int(n), C.double(alpha), (*C.double)(&x[0]), C.int(incX), (*C.double)(&y[0]), C.int(incY), (*C.double)(&a[0]), C.int(lda))
+	C.cblas_dger(C.enum_CBLAS_ORDER(rowMajor), C.blasint(m), C.blasint(n), C.double(alpha), (*C.double)(&x[0]), C.blasint(incX), (*C.double)(&y[0]), C.blasint(incY), (*C.double)(&a[0]), C.blasint(lda))
 }
 func (Implementation) Dsyr(ul blas.Uplo, n int, alpha float64, x []float64, incX int, a []float64, lda int) {
 	if ul != blas.Upper && ul != blas.Lower {
@@ -1978,7 +1978,7 @@ func (Implementation) Dsyr(ul blas.Uplo, n int, alpha float64, x []float64, incX
 	if lda*(n-1)+n > len(a) || lda < max(1, n) {
 		panic("blas: index of a out of range")
 	}
-	C.cblas_dsyr(C.enum_CBLAS_ORDER(rowMajor), C.enum_CBLAS_UPLO(ul), C.int(n), C.double(alpha), (*C.double)(&x[0]), C.int(incX), (*C.double)(&a[0]), C.int(lda))
+	C.cblas_dsyr(C.enum_CBLAS_ORDER(rowMajor), C.enum_CBLAS_UPLO(ul), C.blasint(n), C.double(alpha), (*C.double)(&x[0]), C.blasint(incX), (*C.double)(&a[0]), C.blasint(lda))
 }
 func (Implementation) Dspr(ul blas.Uplo, n int, alpha float64, x []float64, incX int, ap []float64) {
 	if ul != blas.Upper && ul != blas.Lower {
@@ -1996,7 +1996,7 @@ func (Implementation) Dspr(ul blas.Uplo, n int, alpha float64, x []float64, incX
 	if (incX > 0 && (n-1)*incX >= len(x)) || (incX < 0 && (1-n)*incX >= len(x)) {
 		panic("blas: x index out of range")
 	}
-	C.cblas_dspr(C.enum_CBLAS_ORDER(rowMajor), C.enum_CBLAS_UPLO(ul), C.int(n), C.double(alpha), (*C.double)(&x[0]), C.int(incX), (*C.double)(&ap[0]))
+	C.cblas_dspr(C.enum_CBLAS_ORDER(rowMajor), C.enum_CBLAS_UPLO(ul), C.blasint(n), C.double(alpha), (*C.double)(&x[0]), C.blasint(incX), (*C.double)(&ap[0]))
 }
 func (Implementation) Dsyr2(ul blas.Uplo, n int, alpha float64, x []float64, incX int, y []float64, incY int, a []float64, lda int) {
 	if ul != blas.Upper && ul != blas.Lower {
@@ -2020,7 +2020,7 @@ func (Implementation) Dsyr2(ul blas.Uplo, n int, alpha float64, x []float64, inc
 	if lda*(n-1)+n > len(a) || lda < max(1, n) {
 		panic("blas: index of a out of range")
 	}
-	C.cblas_dsyr2(C.enum_CBLAS_ORDER(rowMajor), C.enum_CBLAS_UPLO(ul), C.int(n), C.double(alpha), (*C.double)(&x[0]), C.int(incX), (*C.double)(&y[0]), C.int(incY), (*C.double)(&a[0]), C.int(lda))
+	C.cblas_dsyr2(C.enum_CBLAS_ORDER(rowMajor), C.enum_CBLAS_UPLO(ul), C.blasint(n), C.double(alpha), (*C.double)(&x[0]), C.blasint(incX), (*C.double)(&y[0]), C.blasint(incY), (*C.double)(&a[0]), C.blasint(lda))
 }
 func (Implementation) Dspr2(ul blas.Uplo, n int, alpha float64, x []float64, incX int, y []float64, incY int, ap []float64) {
 	if ul != blas.Upper && ul != blas.Lower {
@@ -2044,7 +2044,7 @@ func (Implementation) Dspr2(ul blas.Uplo, n int, alpha float64, x []float64, inc
 	if (incY > 0 && (n-1)*incY >= len(y)) || (incY < 0 && (1-n)*incY >= len(y)) {
 		panic("blas: y index out of range")
 	}
-	C.cblas_dspr2(C.enum_CBLAS_ORDER(rowMajor), C.enum_CBLAS_UPLO(ul), C.int(n), C.double(alpha), (*C.double)(&x[0]), C.int(incX), (*C.double)(&y[0]), C.int(incY), (*C.double)(&ap[0]))
+	C.cblas_dspr2(C.enum_CBLAS_ORDER(rowMajor), C.enum_CBLAS_UPLO(ul), C.blasint(n), C.double(alpha), (*C.double)(&x[0]), C.blasint(incX), (*C.double)(&y[0]), C.blasint(incY), (*C.double)(&ap[0]))
 }
 func (Implementation) Chemv(ul blas.Uplo, n int, alpha complex64, a []complex64, lda int, x []complex64, incX int, beta complex64, y []complex64, incY int) {
 	if ul != blas.Upper && ul != blas.Lower {
@@ -2068,7 +2068,7 @@ func (Implementation) Chemv(ul blas.Uplo, n int, alpha complex64, a []complex64,
 	if lda*(n-1)+n > len(a) || lda < max(1, n) {
 		panic("blas: index of a out of range")
 	}
-	C.cblas_chemv(C.enum_CBLAS_ORDER(rowMajor), C.enum_CBLAS_UPLO(ul), C.int(n), unsafe.Pointer(&alpha), unsafe.Pointer(&a[0]), C.int(lda), unsafe.Pointer(&x[0]), C.int(incX), unsafe.Pointer(&beta), unsafe.Pointer(&y[0]), C.int(incY))
+	C.cblas_chemv(C.enum_CBLAS_ORDER(rowMajor), C.enum_CBLAS_UPLO(ul), C.blasint(n), unsafe.Pointer(&alpha), unsafe.Pointer(&a[0]), C.blasint(lda), unsafe.Pointer(&x[0]), C.blasint(incX), unsafe.Pointer(&beta), unsafe.Pointer(&y[0]), C.blasint(incY))
 }
 func (Implementation) Chbmv(ul blas.Uplo, n int, k int, alpha complex64, a []complex64, lda int, x []complex64, incX int, beta complex64, y []complex64, incY int) {
 	if ul != blas.Upper && ul != blas.Lower {
@@ -2095,7 +2095,7 @@ func (Implementation) Chbmv(ul blas.Uplo, n int, k int, alpha complex64, a []com
 	if lda*(n-1)+k+1 > len(a) || lda < k+1 {
 		panic("blas: index of a out of range")
 	}
-	C.cblas_chbmv(C.enum_CBLAS_ORDER(rowMajor), C.enum_CBLAS_UPLO(ul), C.int(n), C.int(k), unsafe.Pointer(&alpha), unsafe.Pointer(&a[0]), C.int(lda), unsafe.Pointer(&x[0]), C.int(incX), unsafe.Pointer(&beta), unsafe.Pointer(&y[0]), C.int(incY))
+	C.cblas_chbmv(C.enum_CBLAS_ORDER(rowMajor), C.enum_CBLAS_UPLO(ul), C.blasint(n), C.blasint(k), unsafe.Pointer(&alpha), unsafe.Pointer(&a[0]), C.blasint(lda), unsafe.Pointer(&x[0]), C.blasint(incX), unsafe.Pointer(&beta), unsafe.Pointer(&y[0]), C.blasint(incY))
 }
 func (Implementation) Chpmv(ul blas.Uplo, n int, alpha complex64, ap []complex64, x []complex64, incX int, beta complex64, y []complex64, incY int) {
 	if ul != blas.Upper && ul != blas.Lower {
@@ -2119,7 +2119,7 @@ func (Implementation) Chpmv(ul blas.Uplo, n int, alpha complex64, ap []complex64
 	if (incY > 0 && (n-1)*incY >= len(y)) || (incY < 0 && (1-n)*incY >= len(y)) {
 		panic("blas: y index out of range")
 	}
-	C.cblas_chpmv(C.enum_CBLAS_ORDER(rowMajor), C.enum_CBLAS_UPLO(ul), C.int(n), unsafe.Pointer(&alpha), unsafe.Pointer(&ap[0]), unsafe.Pointer(&x[0]), C.int(incX), unsafe.Pointer(&beta), unsafe.Pointer(&y[0]), C.int(incY))
+	C.cblas_chpmv(C.enum_CBLAS_ORDER(rowMajor), C.enum_CBLAS_UPLO(ul), C.blasint(n), unsafe.Pointer(&alpha), unsafe.Pointer(&ap[0]), unsafe.Pointer(&x[0]), C.blasint(incX), unsafe.Pointer(&beta), unsafe.Pointer(&y[0]), C.blasint(incY))
 }
 func (Implementation) Cgeru(m int, n int, alpha complex64, x []complex64, incX int, y []complex64, incY int, a []complex64, lda int) {
 	if m < 0 {
@@ -2143,7 +2143,7 @@ func (Implementation) Cgeru(m int, n int, alpha complex64, x []complex64, incX i
 	if lda*(m-1)+n > len(a) || lda < max(1, n) {
 		panic("blas: index of a out of range")
 	}
-	C.cblas_cgeru(C.enum_CBLAS_ORDER(rowMajor), C.int(m), C.int(n), unsafe.Pointer(&alpha), unsafe.Pointer(&x[0]), C.int(incX), unsafe.Pointer(&y[0]), C.int(incY), unsafe.Pointer(&a[0]), C.int(lda))
+	C.cblas_cgeru(C.enum_CBLAS_ORDER(rowMajor), C.blasint(m), C.blasint(n), unsafe.Pointer(&alpha), unsafe.Pointer(&x[0]), C.blasint(incX), unsafe.Pointer(&y[0]), C.blasint(incY), unsafe.Pointer(&a[0]), C.blasint(lda))
 }
 func (Implementation) Cgerc(m int, n int, alpha complex64, x []complex64, incX int, y []complex64, incY int, a []complex64, lda int) {
 	if m < 0 {
@@ -2167,7 +2167,7 @@ func (Implementation) Cgerc(m int, n int, alpha complex64, x []complex64, incX i
 	if lda*(m-1)+n > len(a) || lda < max(1, n) {
 		panic("blas: index of a out of range")
 	}
-	C.cblas_cgerc(C.enum_CBLAS_ORDER(rowMajor), C.int(m), C.int(n), unsafe.Pointer(&alpha), unsafe.Pointer(&x[0]), C.int(incX), unsafe.Pointer(&y[0]), C.int(incY), unsafe.Pointer(&a[0]), C.int(lda))
+	C.cblas_cgerc(C.enum_CBLAS_ORDER(rowMajor), C.blasint(m), C.blasint(n), unsafe.Pointer(&alpha), unsafe.Pointer(&x[0]), C.blasint(incX), unsafe.Pointer(&y[0]), C.blasint(incY), unsafe.Pointer(&a[0]), C.blasint(lda))
 }
 func (Implementation) Cher(ul blas.Uplo, n int, alpha float32, x []complex64, incX int, a []complex64, lda int) {
 	if ul != blas.Upper && ul != blas.Lower {
@@ -2185,7 +2185,7 @@ func (Implementation) Cher(ul blas.Uplo, n int, alpha float32, x []complex64, in
 	if lda*(n-1)+n > len(a) || lda < max(1, n) {
 		panic("blas: index of a out of range")
 	}
-	C.cblas_cher(C.enum_CBLAS_ORDER(rowMajor), C.enum_CBLAS_UPLO(ul), C.int(n), C.float(alpha), unsafe.Pointer(&x[0]), C.int(incX), unsafe.Pointer(&a[0]), C.int(lda))
+	C.cblas_cher(C.enum_CBLAS_ORDER(rowMajor), C.enum_CBLAS_UPLO(ul), C.blasint(n), C.float(alpha), unsafe.Pointer(&x[0]), C.blasint(incX), unsafe.Pointer(&a[0]), C.blasint(lda))
 }
 func (Implementation) Chpr(ul blas.Uplo, n int, alpha float32, x []complex64, incX int, ap []complex64) {
 	if ul != blas.Upper && ul != blas.Lower {
@@ -2203,7 +2203,7 @@ func (Implementation) Chpr(ul blas.Uplo, n int, alpha float32, x []complex64, in
 	if (incX > 0 && (n-1)*incX >= len(x)) || (incX < 0 && (1-n)*incX >= len(x)) {
 		panic("blas: x index out of range")
 	}
-	C.cblas_chpr(C.enum_CBLAS_ORDER(rowMajor), C.enum_CBLAS_UPLO(ul), C.int(n), C.float(alpha), unsafe.Pointer(&x[0]), C.int(incX), unsafe.Pointer(&ap[0]))
+	C.cblas_chpr(C.enum_CBLAS_ORDER(rowMajor), C.enum_CBLAS_UPLO(ul), C.blasint(n), C.float(alpha), unsafe.Pointer(&x[0]), C.blasint(incX), unsafe.Pointer(&ap[0]))
 }
 func (Implementation) Cher2(ul blas.Uplo, n int, alpha complex64, x []complex64, incX int, y []complex64, incY int, a []complex64, lda int) {
 	if ul != blas.Upper && ul != blas.Lower {
@@ -2227,7 +2227,7 @@ func (Implementation) Cher2(ul blas.Uplo, n int, alpha complex64, x []complex64,
 	if lda*(n-1)+n > len(a) || lda < max(1, n) {
 		panic("blas: index of a out of range")
 	}
-	C.cblas_cher2(C.enum_CBLAS_ORDER(rowMajor), C.enum_CBLAS_UPLO(ul), C.int(n), unsafe.Pointer(&alpha), unsafe.Pointer(&x[0]), C.int(incX), unsafe.Pointer(&y[0]), C.int(incY), unsafe.Pointer(&a[0]), C.int(lda))
+	C.cblas_cher2(C.enum_CBLAS_ORDER(rowMajor), C.enum_CBLAS_UPLO(ul), C.blasint(n), unsafe.Pointer(&alpha), unsafe.Pointer(&x[0]), C.blasint(incX), unsafe.Pointer(&y[0]), C.blasint(incY), unsafe.Pointer(&a[0]), C.blasint(lda))
 }
 func (Implementation) Chpr2(ul blas.Uplo, n int, alpha complex64, x []complex64, incX int, y []complex64, incY int, ap []complex64) {
 	if ul != blas.Upper && ul != blas.Lower {
@@ -2251,7 +2251,7 @@ func (Implementation) Chpr2(ul blas.Uplo, n int, alpha complex64, x []complex64,
 	if (incY > 0 && (n-1)*incY >= len(y)) || (incY < 0 && (1-n)*incY >= len(y)) {
 		panic("blas: y index out of range")
 	}
-	C.cblas_chpr2(C.enum_CBLAS_ORDER(rowMajor), C.enum_CBLAS_UPLO(ul), C.int(n), unsafe.Pointer(&alpha), unsafe.Pointer(&x[0]), C.int(incX), unsafe.Pointer(&y[0]), C.int(incY), unsafe.Pointer(&ap[0]))
+	C.cblas_chpr2(C.enum_CBLAS_ORDER(rowMajor), C.enum_CBLAS_UPLO(ul), C.blasint(n), unsafe.Pointer(&alpha), unsafe.Pointer(&x[0]), C.blasint(incX), unsafe.Pointer(&y[0]), C.blasint(incY), unsafe.Pointer(&ap[0]))
 }
 func (Implementation) Zhemv(ul blas.Uplo, n int, alpha complex128, a []complex128, lda int, x []complex128, incX int, beta complex128, y []complex128, incY int) {
 	if ul != blas.Upper && ul != blas.Lower {
@@ -2275,7 +2275,7 @@ func (Implementation) Zhemv(ul blas.Uplo, n int, alpha complex128, a []complex12
 	if lda*(n-1)+n > len(a) || lda < max(1, n) {
 		panic("blas: index of a out of range")
 	}
-	C.cblas_zhemv(C.enum_CBLAS_ORDER(rowMajor), C.enum_CBLAS_UPLO(ul), C.int(n), unsafe.Pointer(&alpha), unsafe.Pointer(&a[0]), C.int(lda), unsafe.Pointer(&x[0]), C.int(incX), unsafe.Pointer(&beta), unsafe.Pointer(&y[0]), C.int(incY))
+	C.cblas_zhemv(C.enum_CBLAS_ORDER(rowMajor), C.enum_CBLAS_UPLO(ul), C.blasint(n), unsafe.Pointer(&alpha), unsafe.Pointer(&a[0]), C.blasint(lda), unsafe.Pointer(&x[0]), C.blasint(incX), unsafe.Pointer(&beta), unsafe.Pointer(&y[0]), C.blasint(incY))
 }
 func (Implementation) Zhbmv(ul blas.Uplo, n int, k int, alpha complex128, a []complex128, lda int, x []complex128, incX int, beta complex128, y []complex128, incY int) {
 	if ul != blas.Upper && ul != blas.Lower {
@@ -2302,7 +2302,7 @@ func (Implementation) Zhbmv(ul blas.Uplo, n int, k int, alpha complex128, a []co
 	if lda*(n-1)+k+1 > len(a) || lda < k+1 {
 		panic("blas: index of a out of range")
 	}
-	C.cblas_zhbmv(C.enum_CBLAS_ORDER(rowMajor), C.enum_CBLAS_UPLO(ul), C.int(n), C.int(k), unsafe.Pointer(&alpha), unsafe.Pointer(&a[0]), C.int(lda), unsafe.Pointer(&x[0]), C.int(incX), unsafe.Pointer(&beta), unsafe.Pointer(&y[0]), C.int(incY))
+	C.cblas_zhbmv(C.enum_CBLAS_ORDER(rowMajor), C.enum_CBLAS_UPLO(ul), C.blasint(n), C.blasint(k), unsafe.Pointer(&alpha), unsafe.Pointer(&a[0]), C.blasint(lda), unsafe.Pointer(&x[0]), C.blasint(incX), unsafe.Pointer(&beta), unsafe.Pointer(&y[0]), C.blasint(incY))
 }
 func (Implementation) Zhpmv(ul blas.Uplo, n int, alpha complex128, ap []complex128, x []complex128, incX int, beta complex128, y []complex128, incY int) {
 	if ul != blas.Upper && ul != blas.Lower {
@@ -2326,7 +2326,7 @@ func (Implementation) Zhpmv(ul blas.Uplo, n int, alpha complex128, ap []complex1
 	if (incY > 0 && (n-1)*incY >= len(y)) || (incY < 0 && (1-n)*incY >= len(y)) {
 		panic("blas: y index out of range")
 	}
-	C.cblas_zhpmv(C.enum_CBLAS_ORDER(rowMajor), C.enum_CBLAS_UPLO(ul), C.int(n), unsafe.Pointer(&alpha), unsafe.Pointer(&ap[0]), unsafe.Pointer(&x[0]), C.int(incX), unsafe.Pointer(&beta), unsafe.Pointer(&y[0]), C.int(incY))
+	C.cblas_zhpmv(C.enum_CBLAS_ORDER(rowMajor), C.enum_CBLAS_UPLO(ul), C.blasint(n), unsafe.Pointer(&alpha), unsafe.Pointer(&ap[0]), unsafe.Pointer(&x[0]), C.blasint(incX), unsafe.Pointer(&beta), unsafe.Pointer(&y[0]), C.blasint(incY))
 }
 func (Implementation) Zgeru(m int, n int, alpha complex128, x []complex128, incX int, y []complex128, incY int, a []complex128, lda int) {
 	if m < 0 {
@@ -2350,7 +2350,7 @@ func (Implementation) Zgeru(m int, n int, alpha complex128, x []complex128, incX
 	if lda*(m-1)+n > len(a) || lda < max(1, n) {
 		panic("blas: index of a out of range")
 	}
-	C.cblas_zgeru(C.enum_CBLAS_ORDER(rowMajor), C.int(m), C.int(n), unsafe.Pointer(&alpha), unsafe.Pointer(&x[0]), C.int(incX), unsafe.Pointer(&y[0]), C.int(incY), unsafe.Pointer(&a[0]), C.int(lda))
+	C.cblas_zgeru(C.enum_CBLAS_ORDER(rowMajor), C.blasint(m), C.blasint(n), unsafe.Pointer(&alpha), unsafe.Pointer(&x[0]), C.blasint(incX), unsafe.Pointer(&y[0]), C.blasint(incY), unsafe.Pointer(&a[0]), C.blasint(lda))
 }
 func (Implementation) Zgerc(m int, n int, alpha complex128, x []complex128, incX int, y []complex128, incY int, a []complex128, lda int) {
 	if m < 0 {
@@ -2374,7 +2374,7 @@ func (Implementation) Zgerc(m int, n int, alpha complex128, x []complex128, incX
 	if lda*(m-1)+n > len(a) || lda < max(1, n) {
 		panic("blas: index of a out of range")
 	}
-	C.cblas_zgerc(C.enum_CBLAS_ORDER(rowMajor), C.int(m), C.int(n), unsafe.Pointer(&alpha), unsafe.Pointer(&x[0]), C.int(incX), unsafe.Pointer(&y[0]), C.int(incY), unsafe.Pointer(&a[0]), C.int(lda))
+	C.cblas_zgerc(C.enum_CBLAS_ORDER(rowMajor), C.blasint(m), C.blasint(n), unsafe.Pointer(&alpha), unsafe.Pointer(&x[0]), C.blasint(incX), unsafe.Pointer(&y[0]), C.blasint(incY), unsafe.Pointer(&a[0]), C.blasint(lda))
 }
 func (Implementation) Zher(ul blas.Uplo, n int, alpha float64, x []complex128, incX int, a []complex128, lda int) {
 	if ul != blas.Upper && ul != blas.Lower {
@@ -2392,7 +2392,7 @@ func (Implementation) Zher(ul blas.Uplo, n int, alpha float64, x []complex128, i
 	if lda*(n-1)+n > len(a) || lda < max(1, n) {
 		panic("blas: index of a out of range")
 	}
-	C.cblas_zher(C.enum_CBLAS_ORDER(rowMajor), C.enum_CBLAS_UPLO(ul), C.int(n), C.double(alpha), unsafe.Pointer(&x[0]), C.int(incX), unsafe.Pointer(&a[0]), C.int(lda))
+	C.cblas_zher(C.enum_CBLAS_ORDER(rowMajor), C.enum_CBLAS_UPLO(ul), C.blasint(n), C.double(alpha), unsafe.Pointer(&x[0]), C.blasint(incX), unsafe.Pointer(&a[0]), C.blasint(lda))
 }
 func (Implementation) Zhpr(ul blas.Uplo, n int, alpha float64, x []complex128, incX int, ap []complex128) {
 	if ul != blas.Upper && ul != blas.Lower {
@@ -2410,7 +2410,7 @@ func (Implementation) Zhpr(ul blas.Uplo, n int, alpha float64, x []complex128, i
 	if (incX > 0 && (n-1)*incX >= len(x)) || (incX < 0 && (1-n)*incX >= len(x)) {
 		panic("blas: x index out of range")
 	}
-	C.cblas_zhpr(C.enum_CBLAS_ORDER(rowMajor), C.enum_CBLAS_UPLO(ul), C.int(n), C.double(alpha), unsafe.Pointer(&x[0]), C.int(incX), unsafe.Pointer(&ap[0]))
+	C.cblas_zhpr(C.enum_CBLAS_ORDER(rowMajor), C.enum_CBLAS_UPLO(ul), C.blasint(n), C.double(alpha), unsafe.Pointer(&x[0]), C.blasint(incX), unsafe.Pointer(&ap[0]))
 }
 func (Implementation) Zher2(ul blas.Uplo, n int, alpha complex128, x []complex128, incX int, y []complex128, incY int, a []complex128, lda int) {
 	if ul != blas.Upper && ul != blas.Lower {
@@ -2434,7 +2434,7 @@ func (Implementation) Zher2(ul blas.Uplo, n int, alpha complex128, x []complex12
 	if lda*(n-1)+n > len(a) || lda < max(1, n) {
 		panic("blas: index of a out of range")
 	}
-	C.cblas_zher2(C.enum_CBLAS_ORDER(rowMajor), C.enum_CBLAS_UPLO(ul), C.int(n), unsafe.Pointer(&alpha), unsafe.Pointer(&x[0]), C.int(incX), unsafe.Pointer(&y[0]), C.int(incY), unsafe.Pointer(&a[0]), C.int(lda))
+	C.cblas_zher2(C.enum_CBLAS_ORDER(rowMajor), C.enum_CBLAS_UPLO(ul), C.blasint(n), unsafe.Pointer(&alpha), unsafe.Pointer(&x[0]), C.blasint(incX), unsafe.Pointer(&y[0]), C.blasint(incY), unsafe.Pointer(&a[0]), C.blasint(lda))
 }
 func (Implementation) Zhpr2(ul blas.Uplo, n int, alpha complex128, x []complex128, incX int, y []complex128, incY int, ap []complex128) {
 	if ul != blas.Upper && ul != blas.Lower {
@@ -2458,7 +2458,7 @@ func (Implementation) Zhpr2(ul blas.Uplo, n int, alpha complex128, x []complex12
 	if (incY > 0 && (n-1)*incY >= len(y)) || (incY < 0 && (1-n)*incY >= len(y)) {
 		panic("blas: y index out of range")
 	}
-	C.cblas_zhpr2(C.enum_CBLAS_ORDER(rowMajor), C.enum_CBLAS_UPLO(ul), C.int(n), unsafe.Pointer(&alpha), unsafe.Pointer(&x[0]), C.int(incX), unsafe.Pointer(&y[0]), C.int(incY), unsafe.Pointer(&ap[0]))
+	C.cblas_zhpr2(C.enum_CBLAS_ORDER(rowMajor), C.enum_CBLAS_UPLO(ul), C.blasint(n), unsafe.Pointer(&alpha), unsafe.Pointer(&x[0]), C.blasint(incX), unsafe.Pointer(&y[0]), C.blasint(incY), unsafe.Pointer(&ap[0]))
 }
 func (Implementation) Sgemm(tA blas.Transpose, tB blas.Transpose, m int, n int, k int, alpha float32, a []float32, lda int, b []float32, ldb int, beta float32, c []float32, ldc int) {
 	if tA != blas.NoTrans && tA != blas.Trans && tA != blas.ConjTrans {
@@ -2496,7 +2496,7 @@ func (Implementation) Sgemm(tA blas.Transpose, tB blas.Transpose, m int, n int,
 	if ldc*(m-1)+n > len(c) || ldc < max(1, n) {
 		panic("blas: index of c out of range")
 	}
-	C.cblas_sgemm(C.enum_CBLAS_ORDER(rowMajor), C.enum_CBLAS_TRANSPOSE(tA), C.enum_CBLAS_TRANSPOSE(tB), C.int(m), C.int(n), C.int(k), C.float(alpha), (*C.float)(&a[0]), C.int(lda), (*C.float)(&b[0]), C.int(ldb), C.float(beta), (*C.float)(&c[0]), C.int(ldc))
+	C.cblas_sgemm(C.enum_CBLAS_ORDER(rowMajor), C.enum_CBLAS_TRANSPOSE(tA), C.enum_CBLAS_TRANSPOSE(tB), C.blasint(m), C.blasint(n), C.blasint(k), C.float(alpha), (*C.float)(&a[0]), C.blasint(lda), (*C.float)(&b[0]), C.blasint(ldb), C.float(beta), (*C.float)(&c[0]), C.blasint(ldc))
 }
 func (Implementation) Ssymm(s blas.Side, ul blas.Uplo, m int, n int, alpha float32, a []float32, lda int, b []float32, ldb int, beta float32, c []float32, ldc int) {
 	if s != blas.Left && s != blas.Right {
@@ -2526,7 +2526,7 @@ func (Implementation) Ssymm(s blas.Side, ul blas.Uplo, m int, n int, alpha float
 	if ldc*(m-1)+n > len(c) || ldc < max(1, n) {
 		panic("blas: index of c out of range")
 	}
-	C.cblas_ssymm(C.enum_CBLAS_ORDER(rowMajor), C.enum_CBLAS_SIDE(s), C.enum_CBLAS_UPLO(ul), C.int(m), C.int(n), C.float(alpha), (*C.float)(&a[0]), C.int(lda), (*C.float)(&b[0]), C.int(ldb), C.float(beta), (*C.float)(&c[0]), C.int(ldc))
+	C.cblas_ssymm(C.enum_CBLAS_ORDER(rowMajor), C.enum_CBLAS_SIDE(s), C.enum_CBLAS_UPLO(ul), C.blasint(m), C.blasint(n), C.float(alpha), (*C.float)(&a[0]), C.blasint(lda), (*C.float)(&b[0]), C.blasint(ldb), C.float(beta), (*C.float)(&c[0]), C.blasint(ldc))
 }
 func (Implementation) Ssyrk(ul blas.Uplo, t blas.Transpose, n int, k int, alpha float32, a []float32, lda int, beta float32, c []float32, ldc int) {
 	if ul != blas.Upper && ul != blas.Lower {
@@ -2553,7 +2553,7 @@ func (Implementation) Ssyrk(ul blas.Uplo, t blas.Transpose, n int, k int, alpha
 	if ldc*(n-1)+n > len(c) || ldc < max(1, n) {
 		panic("blas: index of c out of range")
 	}
-	C.cblas_ssyrk(C.enum_CBLAS_ORDER(rowMajor), C.enum_CBLAS_UPLO(ul), C.enum_CBLAS_TRANSPOSE(t), C.int(n), C.int(k), C.float(alpha), (*C.float)(&a[0]), C.int(lda), C.float(beta), (*C.float)(&c[0]), C.int(ldc))
+	C.cblas_ssyrk(C.enum_CBLAS_ORDER(rowMajor), C.enum_CBLAS_UPLO(ul), C.enum_CBLAS_TRANSPOSE(t), C.blasint(n), C.blasint(k), C.float(alpha), (*C.float)(&a[0]), C.blasint(lda), C.float(beta), (*C.float)(&c[0]), C.blasint(ldc))
 }
 func (Implementation) Ssyr2k(ul blas.Uplo, t blas.Transpose, n int, k int, alpha float32, a []float32, lda int, b []float32, ldb int, beta float32, c []float32, ldc int) {
 	if ul != blas.Upper && ul != blas.Lower {
@@ -2583,7 +2583,7 @@ func (Implementation) Ssyr2k(ul blas.Uplo, t blas.Transpose, n int, k int, alpha
 	if ldc*(n-1)+n > len(c) || ldc < max(1, n) {
 		panic("blas: index of c out of range")
 	}
-	C.cblas_ssyr2k(C.enum_CBLAS_ORDER(rowMajor), C.enum_CBLAS_UPLO(ul), C.enum_CBLAS_TRANSPOSE(t), C.int(n), C.int(k), C.float(alpha), (*C.float)(&a[0]), C.int(lda), (*C.float)(&b[0]), C.int(ldb), C.float(beta), (*C.float)(&c[0]), C.int(ldc))
+	C.cblas_ssyr2k(C.enum_CBLAS_ORDER(rowMajor), C.enum_CBLAS_UPLO(ul), C.enum_CBLAS_TRANSPOSE(t), C.blasint(n), C.blasint(k), C.float(alpha), (*C.float)(&a[0]), C.blasint(lda), (*C.float)(&b[0]), C.blasint(ldb), C.float(beta), (*C.float)(&c[0]), C.blasint(ldc))
 }
 func (Implementation) Strmm(s blas.Side, ul blas.Uplo, tA blas.Transpose, d blas.Diag, m int, n int, alpha float32, a []float32, lda int, b []float32, ldb int) {
 	if s != blas.Left && s != blas.Right {
@@ -2616,7 +2616,7 @@ func (Implementation) Strmm(s blas.Side, ul blas.Uplo, tA blas.Transpose, d blas
 	if ldb*(m-1)+n > len(b) || ldb < max(1, n) {
 		panic("blas: index of b out of range")
 	}
-	C.cblas_strmm(C.enum_CBLAS_ORDER(rowMajor), C.enum_CBLAS_SIDE(s), C.enum_CBLAS_UPLO(ul), C.enum_CBLAS_TRANSPOSE(tA), C.enum_CBLAS_DIAG(d), C.int(m), C.int(n), C.float(alpha), (*C.float)(&a[0]), C.int(lda), (*C.float)(&b[0]), C.int(ldb))
+	C.cblas_strmm(C.enum_CBLAS_ORDER(rowMajor), C.enum_CBLAS_SIDE(s), C.enum_CBLAS_UPLO(ul), C.enum_CBLAS_TRANSPOSE(tA), C.enum_CBLAS_DIAG(d), C.blasint(m), C.blasint(n), C.float(alpha), (*C.float)(&a[0]), C.blasint(lda), (*C.float)(&b[0]), C.blasint(ldb))
 }
 func (Implementation) Strsm(s blas.Side, ul blas.Uplo, tA blas.Transpose, d blas.Diag, m int, n int, alpha float32, a []float32, lda int, b []float32, ldb int) {
 	if s != blas.Left && s != blas.Right {
@@ -2649,7 +2649,7 @@ func (Implementation) Strsm(s blas.Side, ul blas.Uplo, tA blas.Transpose, d blas
 	if ldb*(m-1)+n > len(b) || ldb < max(1, n) {
 		panic("blas: index of b out of range")
 	}
-	C.cblas_strsm(C.enum_CBLAS_ORDER(rowMajor), C.enum_CBLAS_SIDE(s), C.enum_CBLAS_UPLO(ul), C.enum_CBLAS_TRANSPOSE(tA), C.enum_CBLAS_DIAG(d), C.int(m), C.int(n), C.float(alpha), (*C.float)(&a[0]), C.int(lda), (*C.float)(&b[0]), C.int(ldb))
+	C.cblas_strsm(C.enum_CBLAS_ORDER(rowMajor), C.enum_CBLAS_SIDE(s), C.enum_CBLAS_UPLO(ul), C.enum_CBLAS_TRANSPOSE(tA), C.enum_CBLAS_DIAG(d), C.blasint(m), C.blasint(n), C.float(alpha), (*C.float)(&a[0]), C.blasint(lda), (*C.float)(&b[0]), C.blasint(ldb))
 }
 func (Implementation) Dgemm(tA blas.Transpose, tB blas.Transpose, m int, n int, k int, alpha float64, a []float64, lda int, b []float64, ldb int, beta float64, c []float64, ldc int) {
 	if tA != blas.NoTrans && tA != blas.Trans && tA != blas.ConjTrans {
@@ -2687,7 +2687,7 @@ func (Implementation) Dgemm(tA blas.Transpose, tB blas.Transpose, m int, n int,
 	if ldc*(m-1)+n > len(c) || ldc < max(1, n) {
 		panic("blas: index of c out of range")
 	}
-	C.cblas_dgemm(C.enum_CBLAS_ORDER(rowMajor), C.enum_CBLAS_TRANSPOSE(tA), C.enum_CBLAS_TRANSPOSE(tB), C.int(m), C.int(n), C.int(k), C.double(alpha), (*C.double)(&a[0]), C.int(lda), (*C.double)(&b[0]), C.int(ldb), C.double(beta), (*C.double)(&c[0]), C.int(ldc))
+	C.cblas_dgemm(C.enum_CBLAS_ORDER(rowMajor), C.enum_CBLAS_TRANSPOSE(tA), C.enum_CBLAS_TRANSPOSE(tB), C.blasint(m), C.blasint(n), C.blasint(k), C.double(alpha), (*C.double)(&a[0]), C.blasint(lda), (*C.double)(&b[0]), C.blasint(ldb), C.double(beta), (*C.double)(&c[0]), C.blasint(ldc))
 }
 func (Implementation) Dsymm(s blas.Side, ul blas.Uplo, m int, n int, alpha float64, a []float64, lda int, b []float64, ldb int, beta float64, c []float64, ldc int) {
 	if s != blas.Left && s != blas.Right {
@@ -2717,7 +2717,7 @@ func (Implementation) Dsymm(s blas.Side, ul blas.Uplo, m int, n int, alpha float
 	if ldc*(m-1)+n > len(c) || ldc < max(1, n) {
 		panic("blas: index of c out of range")
 	}
-	C.cblas_dsymm(C.enum_CBLAS_ORDER(rowMajor), C.enum_CBLAS_SIDE(s), C.enum_CBLAS_UPLO(ul), C.int(m), C.int(n), C.double(alpha), (*C.double)(&a[0]), C.int(lda), (*C.double)(&b[0]), C.int(ldb), C.double(beta), (*C.double)(&c[0]), C.int(ldc))
+	C.cblas_dsymm(C.enum_CBLAS_ORDER(rowMajor), C.enum_CBLAS_SIDE(s), C.enum_CBLAS_UPLO(ul), C.blasint(m), C.blasint(n), C.double(alpha), (*C.double)(&a[0]), C.blasint(lda), (*C.double)(&b[0]), C.blasint(ldb), C.double(beta), (*C.double)(&c[0]), C.blasint(ldc))
 }
 func (Implementation) Dsyrk(ul blas.Uplo, t blas.Transpose, n int, k int, alpha float64, a []float64, lda int, beta float64, c []float64, ldc int) {
 	if ul != blas.Upper && ul != blas.Lower {
@@ -2744,7 +2744,7 @@ func (Implementation) Dsyrk(ul blas.Uplo, t blas.Transpose, n int, k int, alpha
 	if ldc*(n-1)+n > len(c) || ldc < max(1, n) {
 		panic("blas: index of c out of range")
 	}
-	C.cblas_dsyrk(C.enum_CBLAS_ORDER(rowMajor), C.enum_CBLAS_UPLO(ul), C.enum_CBLAS_TRANSPOSE(t), C.int(n), C.int(k), C.double(alpha), (*C.double)(&a[0]), C.int(lda), C.double(beta), (*C.double)(&c[0]), C.int(ldc))
+	C.cblas_dsyrk(C.enum_CBLAS_ORDER(rowMajor), C.enum_CBLAS_UPLO(ul), C.enum_CBLAS_TRANSPOSE(t), C.blasint(n), C.blasint(k), C.double(alpha), (*C.double)(&a[0]), C.blasint(lda), C.double(beta), (*C.double)(&c[0]), C.blasint(ldc))
 }
 func (Implementation) Dsyr2k(ul blas.Uplo, t blas.Transpose, n int, k int, alpha float64, a []float64, lda int, b []float64, ldb int, beta float64, c []float64, ldc int) {
 	if ul != blas.Upper && ul != blas.Lower {
@@ -2774,7 +2774,7 @@ func (Implementation) Dsyr2k(ul blas.Uplo, t blas.Transpose, n int, k int, alpha
 	if ldc*(n-1)+n > len(c) || ldc < max(1, n) {
 		panic("blas: index of c out of range")
 	}
-	C.cblas_dsyr2k(C.enum_CBLAS_ORDER(rowMajor), C.enum_CBLAS_UPLO(ul), C.enum_CBLAS_TRANSPOSE(t), C.int(n), C.int(k), C.double(alpha), (*C.double)(&a[0]), C.int(lda), (*C.double)(&b[0]), C.int(ldb), C.double(beta), (*C.double)(&c[0]), C.int(ldc))
+	C.cblas_dsyr2k(C.enum_CBLAS_ORDER(rowMajor), C.enum_CBLAS_UPLO(ul), C.enum_CBLAS_TRANSPOSE(t), C.blasint(n), C.blasint(k), C.double(alpha), (*C.double)(&a[0]), C.blasint(lda), (*C.double)(&b[0]), C.blasint(ldb), C.double(beta), (*C.double)(&c[0]), C.blasint(ldc))
 }
 func (Implementation) Dtrmm(s blas.Side, ul blas.Uplo, tA blas.Transpose, d blas.Diag, m int, n int, alpha float64, a []float64, lda int, b []float64, ldb int) {
 	if s != blas.Left && s != blas.Right {
@@ -2807,7 +2807,7 @@ func (Implementation) Dtrmm(s blas.Side, ul blas.Uplo, tA blas.Transpose, d blas
 	if ldb*(m-1)+n > len(b) || ldb < max(1, n) {
 		panic("blas: index of b out of range")
 	}
-	C.cblas_dtrmm(C.enum_CBLAS_ORDER(rowMajor), C.enum_CBLAS_SIDE(s), C.enum_CBLAS_UPLO(ul), C.enum_CBLAS_TRANSPOSE(tA), C.enum_CBLAS_DIAG(d), C.int(m), C.int(n), C.double(alpha), (*C.double)(&a[0]), C.int(lda), (*C.double)(&b[0]), C.int(ldb))
+	C.cblas_dtrmm(C.enum_CBLAS_ORDER(rowMajor), C.enum_CBLAS_SIDE(s), C.enum_CBLAS_UPLO(ul), C.enum_CBLAS_TRANSPOSE(tA), C.enum_CBLAS_DIAG(d), C.blasint(m), C.blasint(n), C.double(alpha), (*C.double)(&a[0]), C.blasint(lda), (*C.double)(&b[0]), C.blasint(ldb))
 }
 func (Implementation) Dtrsm(s blas.Side, ul blas.Uplo, tA blas.Transpose, d blas.Diag, m int, n int, alpha float64, a []float64, lda int, b []float64, ldb int) {
 	if s != blas.Left && s != blas.Right {
@@ -2840,7 +2840,7 @@ func (Implementation) Dtrsm(s blas.Side, ul blas.Uplo, tA blas.Transpose, d blas
 	if ldb*(m-1)+n > len(b) || ldb < max(1, n) {
 		panic("blas: index of b out of range")
 	}
-	C.cblas_dtrsm(C.enum_CBLAS_ORDER(rowMajor), C.enum_CBLAS_SIDE(s), C.enum_CBLAS_UPLO(ul), C.enum_CBLAS_TRANSPOSE(tA), C.enum_CBLAS_DIAG(d), C.int(m), C.int(n), C.double(alpha), (*C.double)(&a[0]), C.int(lda), (*C.double)(&b[0]), C.int(ldb))
+	C.cblas_dtrsm(C.enum_CBLAS_ORDER(rowMajor), C.enum_CBLAS_SIDE(s), C.enum_CBLAS_UPLO(ul), C.enum_CBLAS_TRANSPOSE(tA), C.enum_CBLAS_DIAG(d), C.blasint(m), C.blasint(n), C.double(alpha), (*C.double)(&a[0]), C.blasint(lda), (*C.double)(&b[0]), C.blasint(ldb))
 }
 func (Implementation) Cgemm(tA blas.Transpose, tB blas.Transpose, m int, n int, k int, alpha complex64, a []complex64, lda int, b []complex64, ldb int, beta complex64, c []complex64, ldc int) {
 	if tA != blas.NoTrans && tA != blas.Trans && tA != blas.ConjTrans {
@@ -2878,7 +2878,7 @@ func (Implementation) Cgemm(tA blas.Transpose, tB blas.Transpose, m int, n int,
 	if ldc*(m-1)+n > len(c) || ldc < max(1, n) {
 		panic("blas: index of c out of range")
 	}
-	C.cblas_cgemm(C.enum_CBLAS_ORDER(rowMajor), C.enum_CBLAS_TRANSPOSE(tA), C.enum_CBLAS_TRANSPOSE(tB), C.int(m), C.int(n), C.int(k), unsafe.Pointer(&alpha), unsafe.Pointer(&a[0]), C.int(lda), unsafe.Pointer(&b[0]), C.int(ldb), unsafe.Pointer(&beta), unsafe.Pointer(&c[0]), C.int(ldc))
+	C.cblas_cgemm(C.enum_CBLAS_ORDER(rowMajor), C.enum_CBLAS_TRANSPOSE(tA), C.enum_CBLAS_TRANSPOSE(tB), C.blasint(m), C.blasint(n), C.blasint(k), unsafe.Pointer(&alpha), unsafe.Pointer(&a[0]), C.blasint(lda), unsafe.Pointer(&b[0]), C.blasint(ldb), unsafe.Pointer(&beta), unsafe.Pointer(&c[0]), C.blasint(ldc))
 }
 func (Implementation) Csymm(s blas.Side, ul blas.Uplo, m int, n int, alpha complex64, a []complex64, lda int, b []complex64, ldb int, beta complex64, c []complex64, ldc int) {
 	if s != blas.Left && s != blas.Right {
@@ -2908,7 +2908,7 @@ func (Implementation) Csymm(s blas.Side, ul blas.Uplo, m int, n int, alpha compl
 	if ldc*(m-1)+n > len(c) || ldc < max(1, n) {
 		panic("blas: index of c out of range")
 	}
-	C.cblas_csymm(C.enum_CBLAS_ORDER(rowMajor), C.enum_CBLAS_SIDE(s), C.enum_CBLAS_UPLO(ul), C.int(m), C.int(n), unsafe.Pointer(&alpha), unsafe.Pointer(&a[0]), C.int(lda), unsafe.Pointer(&b[0]), C.int(ldb), unsafe.Pointer(&beta), unsafe.Pointer(&c[0]), C.int(ldc))
+	C.cblas_csymm(C.enum_CBLAS_ORDER(rowMajor), C.enum_CBLAS_SIDE(s), C.enum_CBLAS_UPLO(ul), C.blasint(m), C.blasint(n), unsafe.Pointer(&alpha), unsafe.Pointer(&a[0]), C.blasint(lda), unsafe.Pointer(&b[0]), C.blasint(ldb), unsafe.Pointer(&beta), unsafe.Pointer(&c[0]), C.blasint(ldc))
 }
 func (Implementation) Csyrk(ul blas.Uplo, t blas.Transpose, n int, k int, alpha complex64, a []complex64, lda int, beta complex64, c []complex64, ldc int) {
 	if ul != blas.Upper && ul != blas.Lower {
@@ -2935,7 +2935,7 @@ func (Implementation) Csyrk(ul blas.Uplo, t blas.Transpose, n int, k int, alpha
 	if ldc*(n-1)+n > len(c) || ldc < max(1, n) {
 		panic("blas: index of c out of range")
 	}
-	C.cblas_csyrk(C.enum_CBLAS_ORDER(rowMajor), C.enum_CBLAS_UPLO(ul), C.enum_CBLAS_TRANSPOSE(t), C.int(n), C.int(k), unsafe.Pointer(&alpha), unsafe.Pointer(&a[0]), C.int(lda), unsafe.Pointer(&beta), unsafe.Pointer(&c[0]), C.int(ldc))
+	C.cblas_csyrk(C.enum_CBLAS_ORDER(rowMajor), C.enum_CBLAS_UPLO(ul), C.enum_CBLAS_TRANSPOSE(t), C.blasint(n), C.blasint(k), unsafe.Pointer(&alpha), unsafe.Pointer(&a[0]), C.blasint(lda), unsafe.Pointer(&beta), unsafe.Pointer(&c[0]), C.blasint(ldc))
 }
 func (Implementation) Csyr2k(ul blas.Uplo, t blas.Transpose, n int, k int, alpha complex64, a []complex64, lda int, b []complex64, ldb int, beta complex64, c []complex64, ldc int) {
 	if ul != blas.Upper && ul != blas.Lower {
@@ -2965,7 +2965,7 @@ func (Implementation) Csyr2k(ul blas.Uplo, t blas.Transpose, n int, k int, alpha
 	if ldc*(n-1)+n > len(c) || ldc < max(1, n) {
 		panic("blas: index of c out of range")
 	}
-	C.cblas_csyr2k(C.enum_CBLAS_ORDER(rowMajor), C.enum_CBLAS_UPLO(ul), C.enum_CBLAS_TRANSPOSE(t), C.int(n), C.int(k), unsafe.Pointer(&alpha), unsafe.Pointer(&a[0]), C.int(lda), unsafe.Pointer(&b[0]), C.int(ldb), unsafe.Pointer(&beta), unsafe.Pointer(&c[0]), C.int(ldc))
+	C.cblas_csyr2k(C.enum_CBLAS_ORDER(rowMajor), C.enum_CBLAS_UPLO(ul), C.enum_CBLAS_TRANSPOSE(t), C.blasint(n), C.blasint(k), unsafe.Pointer(&alpha), unsafe.Pointer(&a[0]), C.blasint(lda), unsafe.Pointer(&b[0]), C.blasint(ldb), unsafe.Pointer(&beta), unsafe.Pointer(&c[0]), C.blasint(ldc))
 }
 func (Implementation) Ctrmm(s blas.Side, ul blas.Uplo, tA blas.Transpose, d blas.Diag, m int, n int, alpha complex64, a []complex64, lda int, b []complex64, ldb int) {
 	if s != blas.Left && s != blas.Right {
@@ -2998,7 +2998,7 @@ func (Implementation) Ctrmm(s blas.Side, ul blas.Uplo, tA blas.Transpose, d blas
 	if ldb*(m-1)+n > len(b) || ldb < max(1, n) {
 		panic("blas: index of b out of range")
 	}
-	C.cblas_ctrmm(C.enum_CBLAS_ORDER(rowMajor), C.enum_CBLAS_SIDE(s), C.enum_CBLAS_UPLO(ul), C.enum_CBLAS_TRANSPOSE(tA), C.enum_CBLAS_DIAG(d), C.int(m), C.int(n), unsafe.Pointer(&alpha), unsafe.Pointer(&a[0]), C.int(lda), unsafe.Pointer(&b[0]), C.int(ldb))
+	C.cblas_ctrmm(C.enum_CBLAS_ORDER(rowMajor), C.enum_CBLAS_SIDE(s), C.enum_CBLAS_UPLO(ul), C.enum_CBLAS_TRANSPOSE(tA), C.enum_CBLAS_DIAG(d), C.blasint(m), C.blasint(n), unsafe.Pointer(&alpha), unsafe.Pointer(&a[0]), C.blasint(lda), unsafe.Pointer(&b[0]), C.blasint(ldb))
 }
 func (Implementation) Ctrsm(s blas.Side, ul blas.Uplo, tA blas.Transpose, d blas.Diag, m int, n int, alpha complex64, a []complex64, lda int, b []complex64, ldb int) {
 	if s != blas.Left && s != blas.Right {
@@ -3031,7 +3031,7 @@ func (Implementation) Ctrsm(s blas.Side, ul blas.Uplo, tA blas.Transpose, d blas
 	if ldb*(m-1)+n > len(b) || ldb < max(1, n) {
 		panic("blas: index of b out of range")
 	}
-	C.cblas_ctrsm(C.enum_CBLAS_ORDER(rowMajor), C.enum_CBLAS_SIDE(s), C.enum_CBLAS_UPLO(ul), C.enum_CBLAS_TRANSPOSE(tA), C.enum_CBLAS_DIAG(d), C.int(m), C.int(n), unsafe.Pointer(&alpha), unsafe.Pointer(&a[0]), C.int(lda), unsafe.Pointer(&b[0]), C.int(ldb))
+	C.cblas_ctrsm(C.enum_CBLAS_ORDER(rowMajor), C.enum_CBLAS_SIDE(s), C.enum_CBLAS_UPLO(ul), C.enum_CBLAS_TRANSPOSE(tA), C.enum_CBLAS_DIAG(d), C.blasint(m), C.blasint(n), unsafe.Pointer(&alpha), unsafe.Pointer(&a[0]), C.blasint(lda), unsafe.Pointer(&b[0]), C.blasint(ldb))
 }
 func (Implementation) Zgemm(tA blas.Transpose, tB blas.Transpose, m int, n int, k int, alpha complex128, a []complex128, lda int, b []complex128, ldb int, beta complex128, c []complex128, ldc int) {
 	if tA != blas.NoTrans && tA != blas.Trans && tA != blas.ConjTrans {
@@ -3069,7 +3069,7 @@ func (Implementation) Zgemm(tA blas.Transpose, tB blas.Transpose, m int, n int,
 	if ldc*(m-1)+n > len(c) || ldc < max(1, n) {
 		panic("blas: index of c out of range")
 	}
-	C.cblas_zgemm(C.enum_CBLAS_ORDER(rowMajor), C.enum_CBLAS_TRANSPOSE(tA), C.enum_CBLAS_TRANSPOSE(tB), C.int(m), C.int(n), C.int(k), unsafe.Pointer(&alpha), unsafe.Pointer(&a[0]), C.int(lda), unsafe.Pointer(&b[0]), C.int(ldb), unsafe.Pointer(&beta), unsafe.Pointer(&c[0]), C.int(ldc))
+	C.cblas_zgemm(C.enum_CBLAS_ORDER(rowMajor), C.enum_CBLAS_TRANSPOSE(tA), C.enum_CBLAS_TRANSPOSE(tB), C.blasint(m), C.blasint(n), C.blasint(k), unsafe.Pointer(&alpha), unsafe.Pointer(&a[0]), C.blasint(lda), unsafe.Pointer(&b[0]), C.blasint(ldb), unsafe.Pointer(&beta), unsafe.Pointer(&c[0]), C.blasint(ldc))
 }
 func (Implementation) Zsymm(s blas.Side, ul blas.Uplo, m int, n int, alpha complex128, a []complex128, lda int, b []complex128, ldb int, beta complex128, c []complex128, ldc int) {
 	if s != blas.Left && s != blas.Right {
@@ -3099,7 +3099,7 @@ func (Implementation) Zsymm(s blas.Side, ul blas.Uplo, m int, n int, alpha compl
 	if ldc*(m-1)+n > len(c) || ldc < max(1, n) {
 		panic("blas: index of c out of range")
 	}
-	C.cblas_zsymm(C.enum_CBLAS_ORDER(rowMajor), C.enum_CBLAS_SIDE(s), C.enum_CBLAS_UPLO(ul), C.int(m), C.int(n), unsafe.Pointer(&alpha), unsafe.Pointer(&a[0]), C.int(lda), unsafe.Pointer(&b[0]), C.int(ldb), unsafe.Pointer(&beta), unsafe.Pointer(&c[0]), C.int(ldc))
+	C.cblas_zsymm(C.enum_CBLAS_ORDER(rowMajor), C.enum_CBLAS_SIDE(s), C.enum_CBLAS_UPLO(ul), C.blasint(m), C.blasint(n), unsafe.Pointer(&alpha), unsafe.Pointer(&a[0]), C.blasint(lda), unsafe.Pointer(&b[0]), C.blasint(ldb), unsafe.Pointer(&beta), unsafe.Pointer(&c[0]), C.blasint(ldc))
 }
 func (Implementation) Zsyrk(ul blas.Uplo, t blas.Transpose, n int, k int, alpha complex128, a []complex128, lda int, beta complex128, c []complex128, ldc int) {
 	if ul != blas.Upper && ul != blas.Lower {
@@ -3126,7 +3126,7 @@ func (Implementation) Zsyrk(ul blas.Uplo, t blas.Transpose, n int, k int, alpha
 	if ldc*(n-1)+n > len(c) || ldc < max(1, n) {
 		panic("blas: index of c out of range")
 	}
-	C.cblas_zsyrk(C.enum_CBLAS_ORDER(rowMajor), C.enum_CBLAS_UPLO(ul), C.enum_CBLAS_TRANSPOSE(t), C.int(n), C.int(k), unsafe.Pointer(&alpha), unsafe.Pointer(&a[0]), C.int(lda), unsafe.Pointer(&beta), unsafe.Pointer(&c[0]), C.int(ldc))
+	C.cblas_zsyrk(C.enum_CBLAS_ORDER(rowMajor), C.enum_CBLAS_UPLO(ul), C.enum_CBLAS_TRANSPOSE(t), C.blasint(n), C.blasint(k), unsafe.Pointer(&alpha), unsafe.Pointer(&a[0]), C.blasint(lda), unsafe.Pointer(&beta), unsafe.Pointer(&c[0]), C.blasint(ldc))
 }
 func (Implementation) Zsyr2k(ul blas.Uplo, t blas.Transpose, n int, k int, alpha complex128, a []complex128, lda int, b []complex128, ldb int, beta complex128, c []complex128, ldc int) {
 	if ul != blas.Upper && ul != blas.Lower {
@@ -3156,7 +3156,7 @@ func (Implementation) Zsyr2k(ul blas.Uplo, t blas.Transpose, n int, k int, alpha
 	if ldc*(n-1)+n > len(c) || ldc < max(1, n) {
 		panic("blas: index of c out of range")
 	}
-	C.cblas_zsyr2k(C.enum_CBLAS_ORDER(rowMajor), C.enum_CBLAS_UPLO(ul), C.enum_CBLAS_TRANSPOSE(t), C.int(n), C.int(k), unsafe.Pointer(&alpha), unsafe.Pointer(&a[0]), C.int(lda), unsafe.Pointer(&b[0]), C.int(ldb), unsafe.Pointer(&beta), unsafe.Pointer(&c[0]), C.int(ldc))
+	C.cblas_zsyr2k(C.enum_CBLAS_ORDER(rowMajor), C.enum_CBLAS_UPLO(ul), C.enum_CBLAS_TRANSPOSE(t), C.blasint(n), C.blasint(k), unsafe.Pointer(&alpha), unsafe.Pointer(&a[0]), C.blasint(lda), unsafe.Pointer(&b[0]), C.blasint(ldb), unsafe.Pointer(&beta), unsafe.Pointer(&c[0]), C.blasint(ldc))
 }
 func (Implementation) Ztrmm(s blas.Side, ul blas.Uplo, tA blas.Transpose, d blas.Diag, m int, n int, alpha complex128, a []complex128, lda int, b []complex128, ldb int) {
 	if s != blas.Left && s != blas.Right {
@@ -3189,7 +3189,7 @@ func (Implementation) Ztrmm(s blas.Side, ul blas.Uplo, tA blas.Transpose, d blas
 	if ldb*(m-1)+n > len(b) || ldb < max(1, n) {
 		panic("blas: index of b out of range")
 	}
-	C.cblas_ztrmm(C.enum_CBLAS_ORDER(rowMajor), C.enum_CBLAS_SIDE(s), C.enum_CBLAS_UPLO(ul), C.enum_CBLAS_TRANSPOSE(tA), C.enum_CBLAS_DIAG(d), C.int(m), C.int(n), unsafe.Pointer(&alpha), unsafe.Pointer(&a[0]), C.int(lda), unsafe.Pointer(&b[0]), C.int(ldb))
+	C.cblas_ztrmm(C.enum_CBLAS_ORDER(rowMajor), C.enum_CBLAS_SIDE(s), C.enum_CBLAS_UPLO(ul), C.enum_CBLAS_TRANSPOSE(tA), C.enum_CBLAS_DIAG(d), C.blasint(m), C.blasint(n), unsafe.Pointer(&alpha), unsafe.Pointer(&a[0]), C.blasint(lda), unsafe.Pointer(&b[0]), C.blasint(ldb))
 }
 func (Implementation) Ztrsm(s blas.Side, ul blas.Uplo, tA blas.Transpose, d blas.Diag, m int, n int, alpha complex128, a []complex128, lda int, b []complex128, ldb int) {
 	if s != blas.Left && s != blas.Right {
@@ -3222,7 +3222,7 @@ func (Implementation) Ztrsm(s blas.Side, ul blas.Uplo, tA blas.Transpose, d blas
 	if ldb*(m-1)+n > len(b) || ldb < max(1, n) {
 		panic("blas: index of b out of range")
 	}
-	C.cblas_ztrsm(C.enum_CBLAS_ORDER(rowMajor), C.enum_CBLAS_SIDE(s), C.enum_CBLAS_UPLO(ul), C.enum_CBLAS_TRANSPOSE(tA), C.enum_CBLAS_DIAG(d), C.int(m), C.int(n), unsafe.Pointer(&alpha), unsafe.Pointer(&a[0]), C.int(lda), unsafe.Pointer(&b[0]), C.int(ldb))
+	C.cblas_ztrsm(C.enum_CBLAS_ORDER(rowMajor), C.enum_CBLAS_SIDE(s), C.enum_CBLAS_UPLO(ul), C.enum_CBLAS_TRANSPOSE(tA), C.enum_CBLAS_DIAG(d), C.blasint(m), C.blasint(n), unsafe.Pointer(&alpha), unsafe.Pointer(&a[0]), C.blasint(lda), unsafe.Pointer(&b[0]), C.blasint(ldb))
 }
 func (Implementation) Chemm(s blas.Side, ul blas.Uplo, m int, n int, alpha complex64, a []complex64, lda int, b []complex64, ldb int, beta complex64, c []complex64, ldc int) {
 	if s != blas.Left && s != blas.Right {
@@ -3252,7 +3252,7 @@ func (Implementation) Chemm(s blas.Side, ul blas.Uplo, m int, n int, alpha compl
 	if ldc*(m-1)+n > len(c) || ldc < max(1, n) {
 		panic("blas: index of c out of range")
 	}
-	C.cblas_chemm(C.enum_CBLAS_ORDER(rowMajor), C.enum_CBLAS_SIDE(s), C.enum_CBLAS_UPLO(ul), C.int(m), C.int(n), unsafe.Pointer(&alpha), unsafe.Pointer(&a[0]), C.int(lda), unsafe.Pointer(&b[0]), C.int(ldb), unsafe.Pointer(&beta), unsafe.Pointer(&c[0]), C.int(ldc))
+	C.cblas_chemm(C.enum_CBLAS_ORDER(rowMajor), C.enum_CBLAS_SIDE(s), C.enum_CBLAS_UPLO(ul), C.blasint(m), C.blasint(n), unsafe.Pointer(&alpha), unsafe.Pointer(&a[0]), C.blasint(lda), unsafe.Pointer(&b[0]), C.blasint(ldb), unsafe.Pointer(&beta), unsafe.Pointer(&c[0]), C.blasint(ldc))
 }
 func (Implementation) Cherk(ul blas.Uplo, t blas.Transpose, n int, k int, alpha float32, a []complex64, lda int, beta float32, c []complex64, ldc int) {
 	if ul != blas.Upper && ul != blas.Lower {
@@ -3279,7 +3279,7 @@ func (Implementation) Cherk(ul blas.Uplo, t blas.Transpose, n int, k int, alpha
 	if ldc*(n-1)+n > len(c) || ldc < max(1, n) {
 		panic("blas: index of c out of range")
 	}
-	C.cblas_cherk(C.enum_CBLAS_ORDER(rowMajor), C.enum_CBLAS_UPLO(ul), C.enum_CBLAS_TRANSPOSE(t), C.int(n), C.int(k), C.float(alpha), unsafe.Pointer(&a[0]), C.int(lda), C.float(beta), unsafe.Pointer(&c[0]), C.int(ldc))
+	C.cblas_cherk(C.enum_CBLAS_ORDER(rowMajor), C.enum_CBLAS_UPLO(ul), C.enum_CBLAS_TRANSPOSE(t), C.blasint(n), C.blasint(k), C.float(alpha), unsafe.Pointer(&a[0]), C.blasint(lda), C.float(beta), unsafe.Pointer(&c[0]), C.blasint(ldc))
 }
 func (Implementation) Cher2k(ul blas.Uplo, t blas.Transpose, n int, k int, alpha complex64, a []complex64, lda int, b []complex64, ldb int, beta float32, c []complex64, ldc int) {
 	if ul != blas.Upper && ul != blas.Lower {
@@ -3309,7 +3309,7 @@ func (Implementation) Cher2k(ul blas.Uplo, t blas.Transpose, n int, k int, alpha
 	if ldc*(n-1)+n > len(c) || ldc < max(1, n) {
 		panic("blas: index of c out of range")
 	}
-	C.cblas_cher2k(C.enum_CBLAS_ORDER(rowMajor), C.enum_CBLAS_UPLO(ul), C.enum_CBLAS_TRANSPOSE(t), C.int(n), C.int(k), unsafe.Pointer(&alpha), unsafe.Pointer(&a[0]), C.int(lda), unsafe.Pointer(&b[0]), C.int(ldb), C.float(beta), unsafe.Pointer(&c[0]), C.int(ldc))
+	C.cblas_cher2k(C.enum_CBLAS_ORDER(rowMajor), C.enum_CBLAS_UPLO(ul), C.enum_CBLAS_TRANSPOSE(t), C.blasint(n), C.blasint(k), unsafe.Pointer(&alpha), unsafe.Pointer(&a[0]), C.blasint(lda), unsafe.Pointer(&b[0]), C.blasint(ldb), C.float(beta), unsafe.Pointer(&c[0]), C.blasint(ldc))
 }
 func (Implementation) Zhemm(s blas.Side, ul blas.Uplo, m int, n int, alpha complex128, a []complex128, lda int, b []complex128, ldb int, beta complex128, c []complex128, ldc int) {
 	if s != blas.Left && s != blas.Right {
@@ -3339,7 +3339,7 @@ func (Implementation) Zhemm(s blas.Side, ul blas.Uplo, m int, n int, alpha compl
 	if ldc*(m-1)+n > len(c) || ldc < max(1, n) {
 		panic("blas: index of c out of range")
 	}
-	C.cblas_zhemm(C.enum_CBLAS_ORDER(rowMajor), C.enum_CBLAS_SIDE(s), C.enum_CBLAS_UPLO(ul), C.int(m), C.int(n), unsafe.Pointer(&alpha), unsafe.Pointer(&a[0]), C.int(lda), unsafe.Pointer(&b[0]), C.int(ldb), unsafe.Pointer(&beta), unsafe.Pointer(&c[0]), C.int(ldc))
+	C.cblas_zhemm(C.enum_CBLAS_ORDER(rowMajor), C.enum_CBLAS_SIDE(s), C.enum_CBLAS_UPLO(ul), C.blasint(m), C.blasint(n), unsafe.Pointer(&alpha), unsafe.Pointer(&a[0]), C.blasint(lda), unsafe.Pointer(&b[0]), C.blasint(ldb), unsafe.Pointer(&beta), unsafe.Pointer(&c[0]), C.blasint(ldc))
 }
 func (Implementation) Zherk(ul blas.Uplo, t blas.Transpose, n int, k int, alpha float64, a []complex128, lda int, beta float64, c []complex128, ldc int) {
 	if ul != blas.Upper && ul != blas.Lower {
@@ -3366,7 +3366,7 @@ func (Implementation) Zherk(ul blas.Uplo, t blas.Transpose, n int, k int, alpha
 	if ldc*(n-1)+n > len(c) || ldc < max(1, n) {
 		panic("blas: index of c out of range")
 	}
-	C.cblas_zherk(C.enum_CBLAS_ORDER(rowMajor), C.enum_CBLAS_UPLO(ul), C.enum_CBLAS_TRANSPOSE(t), C.int(n), C.int(k), C.double(alpha), unsafe.Pointer(&a[0]), C.int(lda), C.double(beta), unsafe.Pointer(&c[0]), C.int(ldc))
+	C.cblas_zherk(C.enum_CBLAS_ORDER(rowMajor), C.enum_CBLAS_UPLO(ul), C.enum_CBLAS_TRANSPOSE(t), C.blasint(n), C.blasint(k), C.double(alpha), unsafe.Pointer(&a[0]), C.blasint(lda), C.double(beta), unsafe.Pointer(&c[0]), C.blasint(ldc))
 }
 func (Implementation) Zher2k(ul blas.Uplo, t blas.Transpose, n int, k int, alpha complex128, a []complex128, lda int, b []complex128, ldb int, beta float64, c []complex128, ldc int) {
 	if ul != blas.Upper && ul != blas.Lower {
@@ -3396,5 +3396,5 @@ func (Implementation) Zher2k(ul blas.Uplo, t blas.Transpose, n int, k int, alpha
 	if ldc*(n-1)+n > len(c) || ldc < max(1, n) {
 		panic("blas: index of c out of range")
 	}
-	C.cblas_zher2k(C.enum_CBLAS_ORDER(rowMajor), C.enum_CBLAS_UPLO(ul), C.enum_CBLAS_TRANSPOSE(t), C.int(n), C.int(k), unsafe.Pointer(&alpha), unsafe.Pointer(&a[0]), C.int(lda), unsafe.Pointer(&b[0]), C.int(ldb), C.double(beta), unsafe.Pointer(&c[0]), C.int(ldc))
+	C.cblas_zher2k(C.enum_CBLAS_ORDER(rowMajor), C.enum_CBLAS_UPLO(ul), C.enum_CBLAS_TRANSPOSE(t), C.blasint(n), C.blasint(k), unsafe.Pointer(&alpha), unsafe.Pointer(&a[0]), C.blasint(lda), unsafe.Pointer(&b[0]), C.blasint(ldb), C.double(beta), unsafe.Pointer(&c[0]), C.blasint(ldc))
 }
-- 
1.9.3

